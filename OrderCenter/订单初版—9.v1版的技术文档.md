# 订单初版—9.v1版的技术文档

**大纲**

**1.订单系统的正向订单表设计**

**2.订单系统的逆向售后表**

**3.正向订单业务接口**

**4.逆向售后业务接口**

<br>

**1.订单系统的正向订单表设计**

**(1)订单表order_info**

**(2)订单条目表order_item**

**(3)订单支付明细表order_payment_detail**

**(4)订单费用表order_amount**

**(5)订单费用明细表order_amount_detail**

**(6)订单快照表order_snapshot**

**(7)订单配送信息表order_delivery_detail**

**(8)订单操作日志表order_operate_log**

**(9)正向订单相关枚举**

<br>

**(1)订单表order_info**

```
CREATE TABLE `order_info` (
    `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键ID',
    `business_identifier` tinyint(4) NOT NULL COMMENT '接入方业务线标识，1为自营商城',
    `order_id` varchar(50) NOT NULL COMMENT '订单编号',
    `parent_order_id` varchar(50) DEFAULT NULL COMMENT '父订单编号',
    `business_order_id` varchar(50) DEFAULT NULL COMMENT '接入方订单号',
    `order_type` tinyint(4) NOT NULL COMMENT '订单类型 1:一般订单  255:其它',
    `order_status` tinyint(4) NOT NULL COMMENT '订单状态 10:已创建, 30:已履约, 40:出库, 50:配送中, 60:已签收, 70:已取消, 100:已拒收, 255:无效订单',
    `cancel_type` varchar(255) DEFAULT NULL COMMENT '订单取消类型',
    `cancel_time` datetime DEFAULT NULL COMMENT '订单取消时间',
    `seller_id` varchar(50) DEFAULT NULL COMMENT '卖家编号',
    `user_id` varchar(50) DEFAULT NULL COMMENT '买家编号',
    `total_amount` int(11) DEFAULT NULL COMMENT '交易总金额（以分为单位存储）',
    `pay_amount` int(11) DEFAULT NULL COMMENT '交易支付金额',
    `pay_type` tinyint(4) DEFAULT NULL COMMENT '支付方式 10:微信支付 20:支付宝支付',
    `coupon_id` varchar(50) DEFAULT NULL COMMENT '使用的优惠券编号',
    `pay_time` datetime DEFAULT NULL COMMENT '支付时间',
    `expire_time` datetime NOT NULL COMMENT '支付订单截止时间',
    `user_remark` varchar(255) DEFAULT NULL COMMENT '用户备注',
    `delete_status` tinyint(4) NOT NULL COMMENT '订单删除状态 0:未删除  1:已删除',
    `comment_status` tinyint(4) NOT NULL DEFAULT '0' COMMENT '订单评论状态 0:未发表评论  1:已发表评论',
    `ext_json` varchar(1024) DEFAULT NULL COMMENT '扩展信息',
    `gmt_create` datetime NOT NULL COMMENT '创建时间',
    `gmt_modified` datetime NOT NULL COMMENT '更新时间',
    PRIMARY KEY (`id`) USING BTREE,
    UNIQUE KEY `idx_order_id` (`order_id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8 COMMENT='订单表';
```

<br>

**(2)订单条目表order_item**

```
CREATE TABLE `order_item` (
    `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键ID',
    `order_id` varchar(50) NOT NULL COMMENT '订单编号',
    `order_item_id` varchar(50) NOT NULL COMMENT '订单明细编号',
    `product_type` tinyint(4) NOT NULL COMMENT '商品类型 1:普通商品, 2:预售商品',
    `product_id` varchar(50) NOT NULL COMMENT '商品编号',
    `product_img` varchar(255) DEFAULT NULL COMMENT '商品图片',
    `product_name` varchar(50) NOT NULL COMMENT '商品名称',
    `sku_code` varchar(50) NOT NULL COMMENT 'sku编码',
    `sale_quantity` int(11) NOT NULL COMMENT '销售数量',
    `sale_price` int(11) NOT NULL COMMENT '销售单价',
    `origin_amount` int(11) NOT NULL COMMENT '当前商品支付原总价',
    `pay_amount` int(11) NOT NULL COMMENT '交易支付金额',
    `product_unit` varchar(10) NOT NULL COMMENT '商品单位',
    `purchase_price` int(11) DEFAULT NULL COMMENT '采购成本价',
    `seller_id` varchar(50) DEFAULT NULL COMMENT '卖家编号',
    `gmt_create` datetime NOT NULL COMMENT '创建时间',
    `gmt_modified` datetime NOT NULL COMMENT '更新时间',
    PRIMARY KEY (`id`) USING BTREE,
    KEY `idx_order_id` (`order_id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8 COMMENT='订单条目表';
```

<br>

**(3)订单支付明细表order_payment_detail**

```
CREATE TABLE `order_payment_detail` (
    `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键ID',
    `order_id` varchar(50) NOT NULL COMMENT '订单编号',
    `account_type` tinyint(4) NOT NULL COMMENT '账户类型',
    `pay_type` tinyint(4) NOT NULL COMMENT '支付类型  10:微信支付, 20:支付宝支付',
    `pay_status` tinyint(4) NOT NULL COMMENT '支付状态 10:未支付, 20:已支付',
    `pay_amount` int(11) NOT NULL DEFAULT '0' COMMENT '支付金额',
    `pay_time` datetime DEFAULT NULL COMMENT '支付时间',
    `out_trade_no` varchar(50) DEFAULT NULL COMMENT '支付系统交易流水号',
    `pay_remark` varchar(255) DEFAULT NULL COMMENT '支付备注信息',
    `gmt_create` datetime NOT NULL COMMENT '创建时间',
    `gmt_modified` datetime NOT NULL COMMENT '更新时间',
    PRIMARY KEY (`id`) USING BTREE,
    KEY `idx_order_id` (`order_id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='订单支付明细表';
```

<br>

**(4)订单费用表order_amount**

```
CREATE TABLE `order_amount` (
    `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键ID',
    `order_id` varchar(50) NOT NULL COMMENT '订单编号',
    `amount_type` int(11) NOT NULL COMMENT '收费类型',
    `amount` int(11) NOT NULL COMMENT '收费金额',
    `gmt_create` datetime NOT NULL COMMENT '创建时间',
    `gmt_modified` datetime NOT NULL COMMENT '更新时间',
    PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=21 DEFAULT CHARSET=utf8 COMMENT='订单费用表';
```

<br>

**(5)订单费用明细表order_amount_detail**

```
CREATE TABLE `order_amount_detail` (
    `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键ID',
    `order_id` varchar(50) NOT NULL COMMENT '订单编号',
    `product_type` tinyint(4) NOT NULL COMMENT '产品类型',
    `order_item_id` varchar(50) NOT NULL COMMENT '订单明细编号',
    `product_id` varchar(50) NOT NULL COMMENT '商品编号',
    `sku_code` varchar(50) NOT NULL COMMENT 'sku编码',
    `sale_quantity` int(11) NOT NULL COMMENT '销售数量',
    `sale_price` int(11) NOT NULL COMMENT '销售单价',
    `amount_type` tinyint(4) NOT NULL COMMENT '收费类型',
    `amount` int(11) NOT NULL COMMENT '收费金额',
    `gmt_create` datetime NOT NULL COMMENT '创建时间',
    `gmt_modified` datetime NOT NULL COMMENT '更新时间',
    PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=28 DEFAULT CHARSET=utf8 COMMENT='订单费用明细表';
```

<br>

**(6)订单快照表order_snapshot**

```
CREATE TABLE `order_snapshot` (
    `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键ID',
    `order_id` varchar(50) NOT NULL COMMENT '订单号',
    `snapshot_type` tinyint(4) unsigned NOT NULL COMMENT '快照类型',
    `snapshot_json` varchar(2000) NOT NULL COMMENT '订单快照内容',
    `gmt_create` datetime NOT NULL COMMENT '创建时间',
    `gmt_modified` datetime NOT NULL COMMENT '更新时间',
    PRIMARY KEY (`id`) USING BTREE,
    KEY `idx_order_id` (`order_id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 COMMENT='订单快照表';
```

<br>

**(7)订单配送信息表order_delivery_detail**

```
CREATE TABLE `order_delivery_detail` (
    `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键ID',
    `order_id` varchar(50) NOT NULL COMMENT '订单编号',
    `delivery_type` tinyint(4) DEFAULT NULL COMMENT '配送类型',
    `province` varchar(50) DEFAULT NULL COMMENT '省',
    `city` varchar(50) DEFAULT NULL COMMENT '市',
    `area` varchar(50) DEFAULT NULL COMMENT '区',
    `street` varchar(50) DEFAULT NULL COMMENT '街道',
    `detail_address` varchar(255) DEFAULT NULL COMMENT '详细地址',
    `lon` decimal(20,10) DEFAULT NULL COMMENT '经度',
    `lat` decimal(20,10) DEFAULT NULL COMMENT '维度',
    `receiver_name` varchar(50) DEFAULT NULL COMMENT '收货人姓名',
    `receiver_phone` varchar(50) DEFAULT NULL COMMENT '收货人电话',
    `modify_address_count` tinyint(4) NOT NULL DEFAULT '0' COMMENT '调整地址次数',
    `deliverer_no` varchar(50) DEFAULT NULL COMMENT '配送员编号',
    `deliverer_name` varchar(50) DEFAULT NULL COMMENT '配送员姓名',
    `deliverer_phone` varchar(50) DEFAULT NULL COMMENT '配送员手机号',
    `out_stock_time` datetime DEFAULT NULL COMMENT '出库时间',
    `signed_time` datetime DEFAULT NULL COMMENT '签收时间',
    `gmt_create` datetime NOT NULL COMMENT '创建时间',
    `gmt_modified` datetime NOT NULL COMMENT '更新时间',
    PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8 COMMENT='订单配送信息表';
```

<br>

**(8)订单操作日志表order_operate_log**

```
CREATE TABLE `order_operate_log` (
    `id` bigint(20) NOT NULL COMMENT '主键ID',
    `order_id` varchar(50) NOT NULL COMMENT '订单编号',
    `operate_type` tinyint(4) DEFAULT NULL COMMENT '操作类型',
    `pre_status` tinyint(4) DEFAULT NULL COMMENT '前置状态',
    `current_status` tinyint(4) DEFAULT NULL COMMENT '当前状态',
    `remark` varchar(255) DEFAULT NULL COMMENT '备注说明',
    `gmt_create` datetime NOT NULL COMMENT '创建时间',
    `gmt_modified` datetime NOT NULL COMMENT '更新时间',
    PRIMARY KEY (`id`) USING BTREE,
    KEY `idx_order_id` (`order_id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='订单操作日志表';
```

<br>

**(9)正向订单相关枚举**

```
//订单类型枚举
public enum OrderTypeEnum {
    NORMAL(1, "一般订单"),
    UNKNOWN(127, "其他");
    ...
}

//接入方业务线枚举
public enum BusinessIdentifierEnum {
    SELF_MALL(1, "自营商城");
    ...
}

//订单号状态枚举
public enum OrderStatusEnum {
    NULL(0, "未知"),
    CREATED(10, "已创建"),
    PAID(20, "已支付"),
    FULFILL(30, "已履约"),
    OUT_STOCK(40, "出库"),
    DELIVERY(50, "配送中"),
    SIGNED(60, "已签收"),
    CANCELED(70, "已取消"),
    REFUSED(100, "已拒收"),
    INVALID(127, "无效订单");
    ...
}

//支付类型枚举
public enum PayTypeEnum {
    WECHAT_PAY(10, "微信支付"),
    ALI_PAY(20, "支付宝支付");
    ...
}

//支付状态枚举
public enum PayStatusEnum {
    UNPAID(10, "未支付"),
    PAID(20, "已支付");
    ...
}

//费用类型枚举
public enum AmountTypeEnum {
    ORIGIN_PAY_AMOUNT(10, "订单支付原价"),
    COUPON_DISCOUNT_AMOUNT(20, "优惠券抵扣金额"),
    SHIPPING_AMOUNT(30, "运费"),
    BOX_AMOUNT(40, "包装费"),
    REAL_PAY_AMOUNT(50, "实付金额"),
    OTHER_AMOUNT(127, "其他费用");
    ...
}

//账户枚举
public enum AccountTypeEnum {
    THIRD(1, "第三方"),
    OTHER(127, "其他");
    ...
}

//配送方式枚举
public enum DeliveryTypeEnum {
    NULL(0, "无配送方式"),
    SELF(1, "自主配送");
    ...
}

//订单取消类型枚举
public enum OrderCancelTypeEnum {
    USER_CANCELED(0, "用户手动取消"),
    TIMEOUT_CANCELED(1, "超时未支付自动取消"),
    CUSTOMER_CANCELED(2, "用户授权客服取消");
    ...
}

//平台类型枚举
public enum PlatformEnum {
    IOS(10, "苹果APP"),
    ANDROID(20, "安卓APP"),
    WECHAT_APP(30, "微信小程序"),
    WECHAT_H5(40, "微信H5"),
    OTHER(127, "其他");
    ...
}

//商品类型枚举
public enum ProductTypeEnum {
    NORMAL_PRODUCT(1, "普通商品"),
    ADVANCE_SALE(2, "预售商品");
    ...
}

//订单查询类型枚举
public enum QueryDataTypeEnums {
    BASE,//订单基础
    ORDER_ITEM,//订单条⽬
    ORDER_AMOUNT_DETAIL,//订单费⽤明细
    PAYMENT,//订单⽀付
    DELIVERY,//订单配送信息
    AFTER_SALE,//售后
    AFTER_SALE_DETAIL,//售后明细
    AFTER_SALE_PAY,//售后交易
    CHANNEL,//渠道
    AMOUNT,//费⽤
    OPERATE_LOG,//操作⽇志
    SNAPSHOT;//订单快照
}
```

<br>

**2.订单系统的逆向售后表设计**

**(1)订单售后表after_sale_info**

**(2)订单售后条目表after_sale_item**

**(3)售后退款表after_sale_refund**

**(4)售后单变更表after_sale_log**

<br>

**(1)订单售后表after_sale_info**

```
CREATE TABLE `after_sale_info` (
    `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键id',
    `business_identifier` tinyint(4) DEFAULT NULL COMMENT '接入方业务线标识，1自营商城',
    `after_sale_id` bigint(20) NOT NULL COMMENT '售后id',
    `order_id` varchar(50) NOT NULL DEFAULT '' COMMENT '订单号',
    `order_source_channel` tinyint(4) NOT NULL COMMENT '订单来源渠道',
    `user_id` varchar(20) NOT NULL COMMENT '购买用户id',
    `after_sale_status` tinyint(4) NOT NULL COMMENT '售后单状态',
    `order_type` tinyint(4) NOT NULL COMMENT '订单类型',
    `apply_source` tinyint(4) DEFAULT NULL COMMENT '申请售后来源',
    `apply_time` datetime DEFAULT NULL COMMENT '申请售后时间',
    `apply_reason_code` tinyint(4) DEFAULT NULL COMMENT '申请原因编码',
    `apply_reason` varchar(1024) DEFAULT NULL COMMENT '申请原因',
    `review_time` datetime DEFAULT NULL COMMENT '客服审核时间',
    `review_source` tinyint(4) DEFAULT NULL COMMENT '客服审核来源',
    `review_reason_code` tinyint(4) DEFAULT NULL COMMENT '客服审核结果编码',
    `review_reason` varchar(1024) DEFAULT NULL COMMENT '客服审核结果',
    `after_sale_type` tinyint(4) NOT NULL COMMENT '售后类型',
    `after_sale_type_detail` tinyint(4) DEFAULT NULL COMMENT '售后类型详情枚举',
    `apply_refund_amount` int(11) DEFAULT NULL COMMENT '申请退款金额',
    `real_refund_amount` int(11) DEFAULT NULL COMMENT '实际退款金额',
    `remark` varchar(1024) DEFAULT NULL COMMENT '备注',
    `gmt_create` datetime NOT NULL COMMENT '创建时间',
    `gmt_modified` datetime NOT NULL COMMENT '更新时间',
    PRIMARY KEY (`id`),
    KEY `idx_after_sale_type` (`after_sale_type`),
    KEY `idx_order_id` (`order_id`)
) ENGINE=InnoDB AUTO_INCREMENT=125 DEFAULT CHARSET=utf8 COMMENT='订单售后表';
```

<br>

**(2)订单售后条目表after_sale_item**

```
CREATE TABLE `after_sale_item` (
    `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键id',
    `after_sale_id` bigint(20) NOT NULL COMMENT '售后id',
    `order_id` varchar(50) NOT NULL DEFAULT '' COMMENT '订单id',
    `sku_code` varchar(20) NOT NULL DEFAULT '' COMMENT 'sku id',
    `product_name` varchar(1024) NOT NULL COMMENT '商品名',
    `return_quantity` tinyint(4) NOT NULL COMMENT '商品退货数量',
    `product_img` varchar(1024) NOT NULL COMMENT '商品图片地址',
    `origin_amount` int(11) NOT NULL COMMENT '商品总金额',
    `apply_refund_amount` int(11) NOT NULL COMMENT '申请退款金额',
    `real_refund_amount` int(11) NOT NULL COMMENT '实际退款金额',
    `gmt_create` datetime NOT NULL COMMENT '创建时间',
    `gmt_modified` datetime NOT NULL COMMENT '更新时间',
    PRIMARY KEY (`id`) USING BTREE,
    KEY `idx_order_id` (`order_id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='订单售后条目表';
```

<br>

**(3)售后退款表after_sale_refund**

```
CREATE TABLE `after_sale_refund` (
    `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键id',
    `after_sale_id` varchar(64) NOT NULL COMMENT '售后单号',
    `order_id` varchar(64) NOT NULL COMMENT '订单号',
    `after_sale_batch_no` varchar(64) DEFAULT NULL COMMENT '售后批次编号',
    `account_type` tinyint(4) NOT NULL COMMENT '账户类型',
    `pay_type` tinyint(4) NOT NULL COMMENT '支付类型',
    `refund_status` tinyint(4) NOT NULL COMMENT '退款状态',
    `refund_amount` int(11) NOT NULL COMMENT '退款金额',
    `refund_pay_time` datetime DEFAULT NULL COMMENT '退款支付时间',
    `out_trade_no` varchar(64) DEFAULT NULL COMMENT '交易单号',
    `remark` varchar(1024) DEFAULT NULL COMMENT '备注',
    `gmt_create` datetime NOT NULL COMMENT '创建时间',
    `gmt_modified` datetime NOT NULL COMMENT '更新时间',
    PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='售后支付表';
```

<br>

**(4)售后单变更表after_sale_log**

```
CREATE TABLE `after_sale_log` (
    `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键id',
    `after_sale_id` varchar(50) NOT NULL COMMENT '售后单号',
    `pre_status` tinyint(4) NOT NULL COMMENT '前一个状态',
    `current_status` tinyint(4) NOT NULL COMMENT '当前状态',
    `remark` varchar(1024) NOT NULL COMMENT '备注',
    `gmt_create` datetime NOT NULL COMMENT '创建时间',
    `gmt_modified` datetime NOT NULL COMMENT '更新时间',
    PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=40 DEFAULT CHARSET=utf8 COMMENT='售后单变更表';
```

<br>

**(5)逆向售后相关枚举**

```
//售后申请来源枚举
public enum AfterSaleApplySourceEnum {
    USER_APPLY(10, "用户申请退款"),
    SYSTEM(20, "系统自动退款"),
    CUSTOM_APPLY(30, "客服申请退款"),
    USER_RETURN_GOODS(40, "用户申请退货"),
    FULFILL_RETURN_MONEY(50, "履约申请退款"),
    ...
}

//售后申请原因枚举
public enum AfterSaleReasonEnum {
    ITEM_NUM(10, "商品数量原因"),
    ITEM_QUALITY(20, "商品质量原因"),
    ITEM_PACKAGE(30, "商品包装原因"),
    LOGISTICS(40, "物流原因"),
    DELIVERY(50, "快递员原因"),
    USER(60, "用户自己原因"),
    ITEM_PRICE(70, "商品价格原因"),
    CANCEL(80, "取消订单"),
    FORCED_CANCELLATION(90, "平台强制取消订单"),
    DISHONOR(100, "拒收"),
    OTHER(200, "其他");
    ...
}

//售后明细类型枚举
public enum AfterSaleDetailEnum {
    ITEM(0, "普通商品"),
    COUPON(1,"优惠券"),
    FREIGHT(2,"运费");
    ...
}

//售后⽀付状态枚举
public enum AfterSalePaymentStatusEnum {
    APPLYING(10, "申请中"),
    REFUNDING(20, "退款中"),
    REFUNDED(30, "退款成功"),
    FAILED(40, "退款失败");
    ...
}

//售后单状态枚举
public enum AfterSaleStatusEnum {
    UN_CREATED(0, "未创建"),
    COMMITED(10, "提交申请"),
    REVIEW_PASS(20, "审核通过"),
    REVIEW_REJECTED(30, "审核拒绝"),
    REFUNDING(40, "退款中"),
    REFUNDED(50, "退款成功"),
    FAILED(60, "退款失败"),
    CLOSED(70, "已关闭"),
    REOPEN(100, "重新提交申请"),
    REVOKE(127, "撤销成功");
    ...
}

//售后类型枚举
public enum AfterSaleTypeEnum {
    RETURN_MONEY(1, "退款"),
    RETURN_GOODS(2, "退货");
    ...
}
```

<br>

**3.正向订单业务接口**

**(1)生成订单号接口**

**(2)提交订单接口**

**(3)预支付订单接口**

**(4)支付回调接口**

**(5)触发订单履约流程接口**

**(6)接受订单履约接口**

**(7)触发订单物流配送结果事件接口**

**(8)通知订单物流配送结果接口**

**(9)删除订单接口**

**(10)修改配送地址接口**

**(11)查询订单列表接口**

**(12)查询订单详情接口**

<br>

**(1)生成订单号接口**

**一.使用场景**

调⽤⽅提交订单前需要先调⽤该接⼝获取到⼀个正式的订单号，然后作为下单接⼝的⼊参。

<br>

**二.具体实现**

生成的订单号是一个19位的数字。前面的2位是业务类型，⽐如10开头是正向，20开头是逆向。接着的6位是⽇期，接着的8位是序列号，最后的3位是⽤户ID后三位。

其中，8位序列号是基于订单号自增表的⾃增主键⽣成。如果⽤户ID不⾜3位，则前⾯补0。

```
@Service
public class OrderServiceImpl implements OrderService {
    @Autowired
    private OrderNoManager orderNoManager;
    ...

    //生成订单号接口
    //@param genOrderIdRequest 生成订单号入参
    @Override
    public GenOrderIdDTO genOrderId(GenOrderIdRequest genOrderIdRequest) {
        //参数检查
        String userId = genOrderIdRequest.getUserId();
        ParamCheckUtil.checkStringNonEmpty(userId);
        Integer businessIdentifier = genOrderIdRequest.getBusinessIdentifier();
        ParamCheckUtil.checkObjectNonNull(businessIdentifier);
        String orderId = orderNoManager.genOrderId(OrderNoTypeEnum.SALE_ORDER.getCode(), userId);
        GenOrderIdDTO genOrderIdDTO = new GenOrderIdDTO();
        genOrderIdDTO.setOrderId(orderId);

        return genOrderIdDTO;
    }
    ...
}

@Service
public class OrderNoManagerImpl implements OrderNoManager {
    @Autowired
    private OrderAutoNoMapper orderAutoNoMapper;

    @Override
    public String genOrderId(Integer orderNoType, String userId) {
        //检查orderNoType是否正确
        OrderNoTypeEnum orderNoTypeEnum = OrderNoTypeEnum.getByCode(orderNoType);
        if (orderNoTypeEnum == null) {
            throw new OrderBizException(OrderErrorCodeEnum.ORDER_NO_TYPE_ERROR);
        }

        return orderNoType + getOrderIdKey(userId);
    }

    //获取订单ID
    private String getOrderIdKey(String userId) {
        return getDateTimeKey() + getAutoNoKey() + getUserIdKey(userId);
    }

    //生成订单号的中间6位日期
    private String getDateTimeKey() {
        return DateFormatUtil.format(new Date(), "yyMMdd");
    }

    //生成订单号中间的8位序列号
    private String getAutoNoKey() {
        OrderAutoNoDO orderAutoNoDO = new OrderAutoNoDO();
        orderAutoNoMapper.insert(orderAutoNoDO);
        Long autoNo = orderAutoNoDO.getId();

        return String.valueOf(NumberUtil.genNo(autoNo, 8));
    }

    //截取用户ID的后三位
    private String getUserIdKey(String userId) {
        //如果userId的长度大于或等于3，则直接返回
        if (userId.length() >= 3) {
            return userId.substring(userId.length() - 3);
        }

        //如果userId的长度大于或等于3，则直接前面补0
        String userIdKey = userId;
        while (userIdKey.length() != 3) {
            userIdKey = "0" + userIdKey;
        }

        return userIdKey;
    }
}

//订单号类型枚举
public enum OrderNoTypeEnum {
    SALE_ORDER(10, "正向订单号"),
    AFTER_SALE(20, "售后单号");
    private Integer code;
    private String msg;
    ...
}
```

<br>

**(2)提交订单接口**

**一.使用场景**

⽤户选好商品确认提交订单时，调⽤此接⼝⽣单。

<br>

**二.具体实现**

步骤一：⼊参校验，不通过就抛异常

步骤二：调⽤⻛控服务，⻛控检查不通过就抛异常

步骤三：调⽤商品服务，查询订单条⽬商品详情

步骤四：调⽤营销服务，计算订单价格

```
//1.运费计算
# 通过营销中⼼的运费模板表来计算出订单所需运费

//2.优惠券折扣分摊
# 优惠券分摊算法
{
    //实付⾦额
    {
        "realPay": 103,
        "type":1
    }
    //原⽀付⾦额
    {
        "amount": 108,
        "type":2
    }
    //运费
    {
        "deliveryaAmount": 3,
        "type": 4
    }
    //优惠券优惠⾦额
    {
        "couponamount": 5,
        //币 + 红包 + 券包
        "type":7
    }
    //商品⾦额明细
    "itemAmount": {
        {
            sku: '苹果',
            price": '3',
            quantity: 2,
            realPay: 3.5
        }, 
        {
            sku: '李⼦',
            price: '3',
            quantity: 2,
            realPay: 3.5
        }
    }
}
//原价 = sku⾦额 * 数量 + 运费
//实付 = sku⾦额 * 数量 + 运费 - 总优惠⾦额 = sku的实付 + 运费
//苹果的优惠分摊⾦额 = 5*（3*2）/（3*2 + 3*2） = 2.5 
//苹果的实付⾦额 = 3*2 -2.5 = 3.5
//如果计算出的优惠券分摊到⼀条item上存在⼩数时，则向上取整
//然后最后⼀条item分摊的⾦额就⽤优惠⾦额减掉前⾯所有优惠的item分摊的总额
```

步骤五：订单验价

验证服务端计算出的订单⽀付⾦额与前端传递过来的⽀付⾦额是否⼀致。

```
# 订单验价逻辑 
//1.前端会传入⼀个商品售卖价
//2.查询商品服务时，商品服务会给⼀个价格(替换前端的)
//3.进行算价 + 营销中⼼【sku会员价】也会将价格算出来
//4.⽐较算出来的总⾦额和前端给的总⾦额，如果不⼀样就说明下单那⼀刻⾦额变化
```

步骤六：调⽤营销服务，锁定优惠券

步骤七：调⽤库存服务，锁定商品库存

步骤八：保存订单数据到数据库，涉及拆单逻辑

```
//一.如果有多种商品类型，需要拆单
# 拆单的逻辑
//sku1是苹果，sku2是其他预售品，sku1的苹果需要先发货 
//order中有2个sku，其他信息基本都⼀样
//1.首先new order，先去获取⼀个orderId
//2.parentOrderId填⽗单的
//3.地址⻛控⽤户都⼀样
//4.钱要换⼀下
//5.拆单是在算价之前(营销去算价就⾏)
//6.构造出内存中三个订单，⽗单状态作废，⼦单状态10，order_status_log(⽗单10-255 ⼦单10-20)
//7.插库，插⼊进3个单

//二.订单数据相关表 
//订单信息表order_info
//订单条⽬表order_item
//订单配送信息表order_delivery_detail
//订单⽀付明细表order_payment_detail
//订单费⽤表order_amount
//订单费⽤明细表order_amount_detail
//订单状态变更⽇志表order_operate_log
//订单快照信息表order_snapshot
```

步骤九：发送延迟MQ消息取消超时未⽀付订单

<img width="100%" height="100%" alt="image" src="https://github.com/user-attachments/assets/0a293324-5300-4470-a924-94a10a98bcef" />

<br>

**三.技术要点**

**要点一：** 扣减库存 + 锁定优惠券 + 创建订单，使用了分布式事务解决⽅案。也就是使⽤Seata的AT模式来解决，即生成订单的接口添加了@GlobalTransactional注解。

**要点二：** 超时取消订单处理⽅案是⽣成订单之后发送⼀个延迟消费的MQ消息，MQ的消费⽅会消费消息，然后调⽤取消订单的接⼝。

**要点三：** 采⽤Builder模式来构建订单信息对象。

生成订单流程：

```
@Service
public class OrderServiceImpl implements OrderService {
    ...
    //提交订单/生成订单接口
    @GlobalTransactional(rollbackFor = Exception.class)
    @Override
    public CreateOrderDTO createOrder(CreateOrderRequest createOrderRequest) {
        //1.入参检查
        checkCreateOrderRequestParam(createOrderRequest);
        //2.风控检查
        checkRisk(createOrderRequest);
        //3.获取商品信息
        List<ProductSkuDTO> productSkuList = listProductSkus(createOrderRequest);
        //4.计算订单价格
        CalculateOrderAmountDTO calculateOrderAmountDTO = calculateOrderAmount(createOrderRequest, productSkuList);
        //5.验证订单实付金额
        checkRealPayAmount(createOrderRequest, calculateOrderAmountDTO);
        //6.锁定优惠券
        lockUserCoupon(createOrderRequest);
        //7.锁定商品库存
        lockProductStock(createOrderRequest);
        //8.生成订单到数据库
        addNewOrder(createOrderRequest, productSkuList, calculateOrderAmountDTO);
        //9.发送订单延迟消息用于支付超时自动关单
        sendPayOrderTimeoutDelayMessage(createOrderRequest);
        //返回订单信息
        CreateOrderDTO createOrderDTO = new CreateOrderDTO();
        createOrderDTO.setOrderId(createOrderRequest.getOrderId());
        return createOrderDTO;
    }
    ...
}
```

新增订单到数据库：

```
@Service
public class OrderServiceImpl implements OrderService {
    ...
    //新增订单数据到数据库
    private void addNewOrder(CreateOrderRequest createOrderRequest, List<ProductSkuDTO> productSkuList, CalculateOrderAmountDTO calculateOrderAmountDTO) {
        //封装新订单数据
        NewOrderDataHolder newOrderDataHolder = new NewOrderDataHolder();

        //生成主订单
        FullOrderData fullMasterOrderData = addNewMasterOrder(createOrderRequest, productSkuList, calculateOrderAmountDTO);

        //封装主订单数据到NewOrderData对象中
        newOrderDataHolder.appendOrderData(fullMasterOrderData);

        //如果存在多种商品类型，需要按商品类型进行拆单
        Map<Integer, List<ProductSkuDTO>> productTypeMap = productSkuList.stream().collect(Collectors.groupingBy(ProductSkuDTO::getProductType));
        if (productTypeMap.keySet().size() > 1) {
            for (Integer productType : productTypeMap.keySet()) {
                //生成子订单
                FullOrderData fullSubOrderData = addNewSubOrder(fullMasterOrderData, productType);
                //封装子订单数据到NewOrderData对象中
                newOrderDataHolder.appendOrderData(fullSubOrderData);
            }
        }

        //保存订单到数据库

        //订单信息
        List<OrderInfoDO> orderInfoDOList = newOrderDataHolder.getOrderInfoDOList();
        if (!orderInfoDOList.isEmpty()) {
            orderInfoDAO.saveBatch(orderInfoDOList);
        }

        //订单条目
        List<OrderItemDO> orderItemDOList = newOrderDataHolder.getOrderItemDOList();
        if (!orderItemDOList.isEmpty()) {
            orderItemDAO.saveBatch(orderItemDOList);
        }

        //订单配送信息
        List<OrderDeliveryDetailDO> orderDeliveryDetailDOList = newOrderDataHolder.getOrderDeliveryDetailDOList();
        if (!orderDeliveryDetailDOList.isEmpty()) {
            orderDeliveryDetailDAO.saveBatch(orderDeliveryDetailDOList);
        }

        //订单支付信息
        List<OrderPaymentDetailDO> orderPaymentDetailDOList = newOrderDataHolder.getOrderPaymentDetailDOList();
        if (!orderPaymentDetailDOList.isEmpty()) {
            orderPaymentDetailDAO.saveBatch(orderPaymentDetailDOList);
        }

        //订单费用信息
        List<OrderAmountDO> orderAmountDOList = newOrderDataHolder.getOrderAmountDOList();
        if (!orderAmountDOList.isEmpty()) {
            orderAmountDAO.saveBatch(orderAmountDOList);
        }

        //订单费用明细
        List<OrderAmountDetailDO> orderAmountDetailDOList = newOrderDataHolder.getOrderAmountDetailDOList();
        if (!orderAmountDetailDOList.isEmpty()) {
            orderAmountDetailDAO.saveBatch(orderAmountDetailDOList);
        }

        //订单状态变更日志信息
        List<OrderOperateLogDO> orderOperateLogDOList = newOrderDataHolder.getOrderOperateLogDOList();
        if (!orderOperateLogDOList.isEmpty()) {
            orderOperateLogDAO.saveBatch(orderOperateLogDOList);
        }

        //订单快照数据
        List<OrderSnapshotDO> orderSnapshotDOList = newOrderDataHolder.getOrderSnapshotDOList();
        if (!orderSnapshotDOList.isEmpty()) {
            orderSnapshotDAO.saveBatch(orderSnapshotDOList);
        }
    }

    //新增主订单信息订单
    private FullOrderData addNewMasterOrder(CreateOrderRequest createOrderRequest, List<ProductSkuDTO> productSkuList, CalculateOrderAmountDTO calculateOrderAmountDTO) {
        NewOrderBuilder newOrderBuilder = new NewOrderBuilder(createOrderRequest, productSkuList, calculateOrderAmountDTO, orderProperties);
        FullOrderData fullOrderData = newOrderBuilder.buildOrder()
            .buildOrderItems()
            .buildOrderDeliveryDetail()
            .buildOrderPaymentDetail()
            .buildOrderAmount()
            .buildOrderAmountDetail()
            .buildOperateLog()
            .buildOrderSnapshot()
            .build();

        //订单信息
        OrderInfoDO orderInfoDO = fullOrderData.getOrderInfoDO();

        //订单条目信息
        List<OrderItemDO> orderItemDOList = fullOrderData.getOrderItemDOList();

        //订单费用信息
        List<OrderAmountDO> orderAmountDOList = fullOrderData.getOrderAmountDOList();

        //补全地址信息
        OrderDeliveryDetailDO orderDeliveryDetailDO = fullOrderData.getOrderDeliveryDetailDO();
        String detailAddress = getDetailAddress(orderDeliveryDetailDO);
        orderDeliveryDetailDO.setDetailAddress(detailAddress);

        //补全订单状态变更日志
        OrderOperateLogDO orderOperateLogDO = fullOrderData.getOrderOperateLogDO();
        String remark = "创建订单操作0-10";
        orderOperateLogDO.setRemark(remark);

        //补全订单商品快照信息
        List<OrderSnapshotDO> orderSnapshotDOList = fullOrderData.getOrderSnapshotDOList();
        for (OrderSnapshotDO orderSnapshotDO : orderSnapshotDOList) {
            //优惠券信息
            if (orderSnapshotDO.getSnapshotType().equals(SnapshotTypeEnum.ORDER_COUPON.getCode())) {
                ...
            }
            //订单费用信息
            else if (orderSnapshotDO.getSnapshotType().equals(SnapshotTypeEnum.ORDER_AMOUNT.getCode())) {
                orderSnapshotDO.setSnapshotJson(JsonUtil.object2Json(orderAmountDOList));
            }
            //订单条目信息
            else if (orderSnapshotDO.getSnapshotType().equals(SnapshotTypeEnum.ORDER_ITEM.getCode())) {
                orderSnapshotDO.setSnapshotJson(JsonUtil.object2Json(orderItemDOList));
            }
        }

        return fullOrderData;
    }
    ...
}
```

Builder模式构建订单信息对象：

```
@Service
public class OrderServiceImpl implements OrderService {
    private CreateOrderRequest createOrderRequest;
    private List<ProductSkuDTO> productSkuList;
    private CalculateOrderAmountDTO calculateOrderAmountDTO;
    private OrderProperties orderProperties;
    private FullOrderData fullOrderData;

    public NewOrderBuilder(CreateOrderRequest createOrderRequest,
            List<ProductSkuDTO> productSkuList,
            CalculateOrderAmountDTO calculateOrderAmountDTO,
            OrderProperties orderProperties) {
        this.createOrderRequest = createOrderRequest;
        this.productSkuList = productSkuList;
        this.calculateOrderAmountDTO = calculateOrderAmountDTO;
        this.fullOrderData = new FullOrderData();
        this.orderProperties = orderProperties;
    }
    ...

    //构建OrderInfoDO对象
    public NewOrderBuilder buildOrder() {
        OrderInfoDO orderInfoDO = new OrderInfoDO();
        orderInfoDO.setBusinessIdentifier(createOrderRequest.getBusinessIdentifier());
        orderInfoDO.setOrderId(createOrderRequest.getOrderId());
        ...

        orderInfoDO.setDeleteStatus(DeleteStatusEnum.NO.getCode());
        orderInfoDO.setCommentStatus(CommentStatusEnum.NO.getCode());
        fullOrderData.setOrderInfoDO(orderInfoDO);
        return this;
    }

    //构建OrderItemDO对象
    public NewOrderBuilder buildOrderItems() {
        String orderId = createOrderRequest.getOrderId();
        String sellerId = createOrderRequest.getSellerId();
        List<CreateOrderRequest.OrderItemRequest> orderItemRequestList = createOrderRequest.getOrderItemRequestList();
        ...

        fullOrderData.setOrderItemDOList(orderItemDOList);
        return this;
    }
    ...

    public FullOrderData build() {
        return this.fullOrderData;
    }
}
```

<br>

**(3)预支付订单接口**

**一.使用场景**

⽤户完成订单提交后需要对订单进⾏⽀付。点击"去⽀付"按钮后，系统调⽤此接⼝完成订单与⽀付，接口调用成功后前端会引导⽤户跳转到⽀付界⾯。

进行预支付处理，主要是为了生成一些信息给第三方支付平台的支付界面。这些支付订单的信息包括：支付商品的名称、支付流水号、支付金额等，这些数据需要支付系统提供并传递给第三方支付平台。

<br>

**二.具体实现**

步骤一：查询订单信息

步骤二：加⽀付分布式锁

步骤三：校验订单信息

步骤四：组装请求参数

步骤五：调⽤⽀付系统进⾏预⽀付

步骤六：更新(是否拆单)订单表与⽀付信息表

<img width="100%" height="100%" alt="image" src="https://github.com/user-attachments/assets/092d884a-396f-4c3a-813e-7562b08af031" />

<br>

**三.技术要点**

多线程并发安全解决⽅案：⽤户可能触发多次订单⽀付，也就是可能会多次调⽤预⽀付接⼝。预⽀付订单接⼝会更改订单与⽀付记录，⽀付回调也会判断订单⽀付状态。所以预⽀付与⽀付回调两个接⼝需要基于分布式锁来保证数据并发安全，这里使⽤Redisson框架的分布式锁。

```
@Service
public class OrderServiceImpl implements OrderService {
    ...
    //预支付订单
    @Override
    @Transactional(rollbackFor = Exception.class)
    public PrePayOrderDTO prePayOrder(PrePayOrderRequest prePayOrderRequest) {
        //1.入参检查
        checkPrePayOrderRequestParam(prePayOrderRequest);
        String orderId = prePayOrderRequest.getOrderId();
        Integer payAmount = prePayOrderRequest.getPayAmount();

        //2.加分布式锁(与订单支付回调时加的是同一把锁)
        String key = RedisLockKeyConstants.ORDER_PAY_KEY + orderId;
        boolean lock = redisLock.lock(key);
        if (!lock) {
            throw new OrderBizException(OrderErrorCodeEnum.ORDER_PRE_PAY_ERROR);
        }

        try {
            //3.预支付订单前的检查
            checkPrePayOrderInfo(orderId, payAmount);

            //4.调用支付系统进行预支付
            PayOrderRequest payOrderRequest = prePayOrderRequest.clone(PayOrderRequest.class);
            JsonResult<PayOrderDTO> jsonResult = payApi.payOrder(payOrderRequest);
            if (!jsonResult.getSuccess()) {
                throw new OrderBizException(OrderErrorCodeEnum.ORDER_PRE_PAY_ERROR);
            }
            PayOrderDTO payOrderDTO = jsonResult.getData();

            //5.更新订单表与支付信息表
            updateOrderPaymentInfo(payOrderDTO);
            return payOrderDTO.clone(PrePayOrderDTO.class);
        } finally {
            //6.释放分布式锁
            redisLock.unlock(key);
        }
    }
    ...
}

//预支付订单对象
@Data
public class PrePayOrderRequest extends AbstractObject implements Serializable {
    private static final long serialVersionUID = -634137320435888212L;
    private String userId;//用户ID
    private String businessIdentifier;//业务方标识
    private Integer payType;//支付类型
    private String orderId;//订单ID
    private Integer payAmount;//订单支付金额
    private String callbackUrl;//支付成功后跳转地址
    private String callbackFailUrl;//支付失败跳转地址
    private String openid;//微信openid
    private String subject;//订单摘要
    private String itemInfo;//商品明细json
}
```

<br>

**(4)支付回调接口**

**一.使用场景**

此接⼝是⽀付系统完成了⽤户⽀付操作之后⾃动来回调的，不是前端应⽤来发起调⽤的。

<br>

**二.具体实现**

步骤一：回调⼊参检查

步骤二：添加分布式锁(与预⽀付接⼝相同)

步骤三：订单状态与⽀付信息判断

步骤四：异常场景判断

正常情况下会修改订单状态与⽀付状态为已⽀付，并记录操作⽇志。异常情况下则需要分类进⾏判断，做各种处理。

<img width="100%" height="100%" alt="image" src="https://github.com/user-attachments/assets/7e6cab61-bda0-414f-9365-d67d1a798061" />

<br>

**三.技术要点**

由于⽤户可能发起多次预⽀付调⽤，所以预⽀付与⽀付回调两个接⼝需要使⽤同⼀把分布式锁，以此来保证并发数据处理安全。

```
@Service
public class OrderServiceImpl implements OrderService {
    ...
    //支付回调
    @Transactional(rollbackFor = Exception.class)
    @Override
    public void payCallback(PayCallbackRequest payCallbackRequest) {
        //1.入参检查
        checkPayCallbackRequestParam(payCallbackRequest);
        String orderId = payCallbackRequest.getOrderId();
        Integer payAmount = payCallbackRequest.getPayAmount();
        Integer payType = payCallbackRequest.getPayType();

        //2.加支付分布式锁避免支付系统并发回调
        String key = RedisLockKeyConstants.ORDER_PAY_KEY + orderId;
        boolean lock = redisLock.lock(key);
        if (!lock) {
            throw new OrderBizException(OrderErrorCodeEnum.ORDER_PAY_CALLBACK_ERROR);
        }

        try {
            //从数据库中查询出当前订单信息
            OrderInfoDO orderInfoDO = orderInfoDAO.getByOrderId(orderId);
            OrderPaymentDetailDO orderPaymentDetailDO = orderPaymentDetailDAO.getPaymentDetailByOrderId(orderId);

            //3.校验参数
            if (orderInfoDO == null || orderPaymentDetailDO == null) {
                throw new OrderBizException(OrderErrorCodeEnum.ORDER_INFO_IS_NULL);
            }
            if (!payAmount.equals(orderInfoDO.getPayAmount())) {
                throw new OrderBizException(OrderErrorCodeEnum.ORDER_CALLBACK_PAY_AMOUNT_ERROR);
            }

            //4.异常场景判断
            Integer orderStatus = orderInfoDO.getOrderStatus();
            if (OrderStatusEnum.CREATED.getCode().equals(orderStatus)) {
                //如果订单状态是"已创建"，直接更新订单状态为已支付
                updateOrderStatusPaid(payCallbackRequest, orderInfoDO, orderPaymentDetailDO);
                //发送"订单已完成支付"消息
                sendPaidOrderSuccessMessage(orderInfoDO);
            } else {
                //如果订单状态不是"已创建"
                if (OrderStatusEnum.CANCELED.getCode().equals(orderStatus)) {
                    //如果订单状态是取消状态
                    Integer payStatus = orderPaymentDetailDO.getPayStatus();
                    if (PayStatusEnum.UNPAID.getCode().equals(payStatus)) {
                        //调用退款
                        executeOrderRefund(orderInfoDO, orderPaymentDetailDO);
                        throw new OrderBizException(OrderErrorCodeEnum.ORDER_CANCEL_PAY_CALLBACK_ERROR);
                    } else if (PayStatusEnum.PAID.getCode().equals(payStatus)) {
                        if (payType.equals(orderPaymentDetailDO.getPayType())) {
                            throw new OrderBizException(OrderErrorCodeEnum.ORDER_CANCEL_PAY_CALLBACK_PAY_TYPE_SAME_ERROR);
                        } else {
                            throw new OrderBizException(OrderErrorCodeEnum.ORDER_CANCEL_PAY_CALLBACK_PAY_TYPE_NO_SAME_ERROR);
                        }
                    }
                } else {
                    //如果订单状态不是取消状态
                    if (PayStatusEnum.PAID.getCode().equals(orderPaymentDetailDO.getPayStatus())) {
                        if (payType.equals(orderPaymentDetailDO.getPayType())) {
                            return;
                        }
                        //调用退款
                        executeOrderRefund(orderInfoDO, orderPaymentDetailDO);
                        throw new OrderBizException(OrderErrorCodeEnum.ORDER_CANCEL_PAY_CALLBACK_REPEAT_ERROR);
                    }
                }
            }
        } finally {
            //释放分布式锁
            redisLock.unlock(key);
        }
    }
    ...
}

//支付系统回调请求对象
@Data
public class PayCallbackRequest extends AbstractObject implements Serializable {
    private static final long serialVersionUID = 3685085492927992753L;
    private String orderId;//订单ID
    private String payAccount;//支付账户
    private Integer payAmount;//支付金额
    private String outTradeNo;//支付系统交易单号
    private Integer payType;//支付方式
    private String merchantId;//商户号
    private String payChannel;//支付渠道
    private String appid;//微信平台 appid
}
```

<br>

**(5)触发订单履约流程接口**

**一.使用场景**

订单系统监听到"订单已⽀付"消息时触发。

<br>

**二.业务规则**

⽀付成功的订单需要推送给履约系统进⾏履约。

<br>

**三.业务流程**

步骤一：订单系统监听RocketMQ的订单已⽀付消息

步骤二：订单系统收到订单已⽀付消息后查询出订单

步骤三：校验订单是否已⽀付，如果不是则终⽌流程

步骤四：构造履约请求，调⽤履约系统的履约接⼝

步骤五：如果调⽤失败则抛异常 + 重复消费消息

步骤六：如果调⽤成功则更新订单状态 + 记录变更

步骤七：⼿动提交ack

<img width="100%" height="100%" alt="image" src="https://github.com/user-attachments/assets/63257904-3312-40a3-9079-5ca33ed387b4" />

<br>

**四.技术要点**

**要点一：** 订单系统调⽤履约系统接⼝失败时，需要抛异常。通过RocketMQ的消息重复消费功能，重新执⾏订单履约流程。

**要点二：** 消息消费幂等，通过分布式锁 + 状态前置校验实现。

**要点三：** 加分布式锁应放在本地事务外，⽽不能将加锁包裹在本地事务⾥。

**要点四：** 需要考虑调⽤履约系统接⼝成功，但是本地事务执⾏失败的可能，也就是需要保证调⽤履约系统接⼝和本地事务执⾏的最终⼀致性，因此使⽤RocketMQ的事务消息来实现。

```
//监听订单支付成功的消息
@Component
public class PaidOrderSuccessListener implements MessageListenerConcurrently {
    @Autowired
    RedisLock redisLock;

    @Autowired
    private OrderFulFillService orderFulFillService;

    @Override
    public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> list, ConsumeConcurrentlyContext consumeConcurrentlyContext) {
        try {
            for (MessageExt messageExt : list) {
                String message = new String(messageExt.getBody());
                PaidOrderSuccessMessage paidOrderSuccessMessage = JSON.parseObject(message, PaidOrderSuccessMessage.class);
                String orderId = paidOrderSuccessMessage.getOrderId();
                log.info("触发订单履约，orderId:{}", orderId);

                //1.加分布式锁 + 里面的履约前置状态校验防止消息重复消费
                String key = RedisLockKeyConstants.ORDER_FULFILL_KEY + orderId;
                boolean lock = redisLock.lock(key);
                if (!lock) {
                    log.error("order has not acquired lock，cannot fulfill, orderId={}", orderId);
                    throw new BaseBizException(OrderErrorCodeEnum.ORDER_FULFILL_ERROR);
                }

                try {
                    //2.触发订单履约逻辑
                    //注意这里分布式锁加锁放在了本地事务外面
                    orderFulFillService.triggerOrderFulFill(orderId);
                } finally {
                    if (lock) {
                        redisLock.unlock(key);
                    }
                }
            }
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
        } catch (Exception e) {
            log.error("consumer error", e);
            //本地业务逻辑执行失败，触发消息重新消费
            return ConsumeConcurrentlyStatus.RECONSUME_LATER;
        }
    }
}

@Service
public class OrderFulFillServiceImpl implements OrderFulFillService {
    ...
    //履约服务
    @DubboReference(version = "1.0.0", retries = 0)
    private FulfillApi fulfillApi;

    @Transactional(rollbackFor = Exception.class)
    @Override
    public void triggerOrderFulFill(String orderId) throws OrderBizException {
        //1.获取订单数据
        OrderInfoDO order = orderInfoDAO.getByOrderId(orderId);
        if (Objects.isNull(order)) {
            return;
        }

        //2.校验订单是否已支付
        OrderStatusEnum orderStatus = OrderStatusEnum.getByCode(order.getOrderStatus());
        if (!OrderStatusEnum.PAID.equals(orderStatus)) {
            log.info("order has not been paid，cannot fulfill, orderId={}", order.getOrderId());
            return;
        }

        //3.推送订单至履约系统
        JsonResult<Boolean> jsonResult = fulfillApi.receiveOrderFulFill(buildReceiveFulFillRequest(order));
        if (!jsonResult.getSuccess()) {
            log.error("push order to fulfill-system error,orderId={}", order.getOrderId());
            throw new OrderBizException(OrderErrorCodeEnum.ORDER_FULFILL_ERROR);
        }

        //4.更新订单状态为：已履约
        orderInfoDAO.updateOrderStatus(orderId, OrderStatusEnum.PAID.getCode(), OrderStatusEnum.FULFILL.getCode());

        //5.并插入一条订单变更记录
        orderOperateLogDAO.save(orderOperateLogFactory.get(order, OrderStatusChangeEnum.ORDER_FULFILLED));
        // TODO 使用事务消息，解决：推送履约系统成功，但是执行本地事物失败的场景
    }
    ...
}
```

<br>

**(6)接受订单履约接口**

**一.使用场景**

订单系统触发履约流程时会调⽤该接⼝，将订单履约信息推送给履约系统。

<br>

**二.具体实现**

履约服务需要提供该接⼝进⾏后续的订单履约操作。这⾥的履约系统将扮演"仓储 + 物流"的⻆⾊，进⾏后续的商品捡货出库、商品打包邮寄配送、以及包裹签收的流程。具体如下所示：

<img width="100%" height="100%" alt="image" src="https://github.com/user-attachments/assets/a5f019e8-7c45-4ede-ad0d-d3f48f29cb5d" />

```
@DubboService(version = "1.0.0", interfaceClass = FulfillApi.class, retries = 0)
public class FulfillApiImpl implements FulfillApi {
    @Override
    public JsonResult<Boolean> receiveOrderFulFill(ReceiveFulFillRequest request) {
        ...
        log.info("接受订单履约成功，request={}", JSONObject.toJSONString(request));
        return JsonResult.buildSuccess(true);
    }
    ...
}

//接受订单履约请求
@Data
@Builder
public class ReceiveFulFillRequest implements Serializable {
    private String orderId;//订单号
    private String sellerId;//商家id
    private String userId;//用户id
    private Integer deliveryType;//配送类型，默认是自配送
    private String receiverName;//收货人姓名
    private String receiverPhone;//收货人电话
    private String receiverProvince;//省
    private String receiverCity;//市
    private String receiverArea;//区
    private String receiverStreetAddress;//街道地址
    private String receiverDetailAddress;//详细地址
    private BigDecimal receiverLon;//经度 六位小数点
    private BigDecimal receiverLat;//纬度 六位小数点
    private String shopRemark;//商家备注
    private String userRemark;//用户备注
    private Integer payType;//支付方式
    private Integer payAmount;//付款总金额
    private Integer totalAmount;//交易总金额
    private Integer deliveryAmount;//运费
    private List<ReceiveOrderItemRequest> receiveOrderItems;//订单商品明细

    @Tolerate
    public ReceiveFulFillRequest() {
    }
}

//履约订单商品明细请求
@Data
@Builder
public class ReceiveOrderItemRequest implements Serializable {
    private String skuCode;//商品id
    private String productName;//商品名称
    private Integer salePrice;//销售单价
    private Integer saleQuantity;//销售数量
    private String productUnit;//商品单位
    private Integer payAmount;//付款金额
    private Integer originAmount;//当前商品支付原总价

    @Tolerate
    public ReceiveOrderItemRequest() {
    }
}
```

<br>

**(7)触发订单物流配送结果事件接口**

**一.使用场景**

⼀个⼯具类接⼝，模拟触发履约后的流程。触发订单已出库事件、订单已配送事件、订单已签收事件。

<br>

**二.具体实现**

根据传⼊的参数，构造订单已出库、订单已配件、订单已签收等事件，并发送到对应的topic上去。

```
@DubboService(version = "1.0.0", interfaceClass = FulfillApi.class, retries = 0)
public class FulfillApiImpl implements FulfillApi {
    ...
    @Override
    public JsonResult<Boolean> triggerOrderWmsShipEvent(String orderId, OrderStatusChangeEnum orderStatusChange, BaseWmsShipEvent wmsEvent) {
        log.info("触发订单物流配送结果事件，orderId={},orderStatusChange={},wmsEvent={}", orderId, orderStatusChange, JSONObject.toJSONString(wmsEvent));
        Message message = null;
        String body = null;
        if (OrderStatusChangeEnum.ORDER_OUT_STOCKED.equals(orderStatusChange)) {
            message = new Message();
            //订单已出库事件
            OrderOutStockWmsEvent outStockEvent = (OrderOutStockWmsEvent) wmsEvent;
            outStockEvent.setOrderId(orderId);
            //构建订单已出库消息体
            OrderEvent<OrderOutStockWmsEvent> orderEvent = buildOrderEvent(orderId, OrderStatusChangeEnum.ORDER_OUT_STOCKED, outStockEvent, OrderOutStockWmsEvent.class);
            body = JSONObject.toJSONString(orderEvent);
        } else if (OrderStatusChangeEnum.ORDER_DELIVERED.equals(orderStatusChange)) {
            message = new Message();
            //订单已配送事件
            OrderDeliveredWmsEvent deliveredWmsEvent = (OrderDeliveredWmsEvent) wmsEvent;
            deliveredWmsEvent.setOrderId(orderId);
            //构建订单已配送消息体
            OrderEvent<OrderDeliveredWmsEvent> orderEvent = buildOrderEvent(orderId, OrderStatusChangeEnum.ORDER_DELIVERED, deliveredWmsEvent, OrderDeliveredWmsEvent.class);
            body = JSONObject.toJSONString(orderEvent);
        } else if (OrderStatusChangeEnum.ORDER_SIGNED.equals(orderStatusChange)) {
            message = new Message();
            //订单已签收事件
            OrderSignedWmsEvent signedWmsEvent = (OrderSignedWmsEvent) wmsEvent;
            signedWmsEvent.setOrderId(orderId);
            //构建订单已签收消息体
            OrderEvent<OrderSignedWmsEvent> orderEvent = buildOrderEvent(orderId, OrderStatusChangeEnum.ORDER_SIGNED, signedWmsEvent, OrderSignedWmsEvent.class);
            body = JSONObject.toJSONString(orderEvent);
        }

        if (null != message) {
            message.setTopic(RocketMqConstant.ORDER_WMS_SHIP_RESULT_TOPIC);
            message.setBody(body.getBytes(StandardCharsets.UTF_8));
            try {
                DefaultMQProducer defaultMQProducer = defaultProducer.getProducer();
                SendResult sendResult = defaultMQProducer.send(message, new MessageQueueSelector() {
                    @Override
                    public MessageQueue select(List<MessageQueue> mqs, Message message, Object arg) {
                        //根据订单id选择发送queue
                        String orderId = (String) arg;
                        long index = hash(orderId) % mqs.size();
                        return mqs.get((int) index);
                    }
                }, orderId);
                log.info("send order wms ship result message finished，SendResult status:%s, queueId:%d, body:%s", sendResult.getSendStatus(), sendResult.getMessageQueue().getQueueId(), body);
            } catch (Exception e) {
                log.error("send order wms ship result message error,orderId={},err={}", orderId, e.getMessage(), e);
            }
        }
        return JsonResult.buildSuccess(true);
    }
    ...
}

//订单状态变化枚举
@Getter
public enum OrderStatusChangeEnum {
    //订单已履约
    ORDER_FULFILLED(OrderStatusEnum.PAID, OrderStatusEnum.FULFILL, OrderOperateTypeEnum.PUSH_ORDER_FULFILL),
    //订单已出库
    ORDER_OUT_STOCKED(OrderStatusEnum.FULFILL, OrderStatusEnum.OUT_STOCK, OrderOperateTypeEnum.ORDER_OUT_STOCK),
    //订单已配送
    ORDER_DELIVERED(OrderStatusEnum.OUT_STOCK, OrderStatusEnum.DELIVERY, OrderOperateTypeEnum.ORDER_DELIVERED),
    //订单已签收
    ORDER_SIGNED(OrderStatusEnum.DELIVERY, OrderStatusEnum.SIGNED, OrderOperateTypeEnum.ORDER_SIGNED),
    ...
}
```

<br>

**(8)通知订单物流配送结果接口**

**一.使用场景**

监听到订单物流配送结果事件时触发，这些事件是订单已出库事件、订单已配送事件、订单已签收事件。

<br>

**二.具体实现**

**情况一：** 订单系统监听到"订单已出库消息"

首先，校验订单状态，如果订单状态不是已履约，流程直接结束。然后，订单配送表增加出库时间。接着，更新订单状态为已出库，并增加⼀条操作⽇志。

<br>

**情况二：** 订单系统监听到"订单已配送消息"

首先，校验订单状态，如果订单状态不是已出库，流程直接结束。然后，订单配送表增加配送员信息(编号、⼿机、姓名)。接着，更新订单状态为已配送，并增加⼀条操作⽇志。

<br>

**情况三：** 订单系统监听到"订单已签收消息"

首先，校验订单状态，如果订单状态不是已签收，流程直接结束。然后，订单配送表增加签收时间。接着，更新订单状态为签收，并增加⼀条操作⽇志。

<img width="100%" height="100%" alt="image" src="https://github.com/user-attachments/assets/8ec44b6e-8c5a-412a-999c-09325e22cbba" />

<br>

**三.技术要点**

**要点一：** 本地业务逻辑需要加本地数据库事务。当本地事务执⾏失败时需要抛异常，触发MQ的消息重复消费功能，重新执⾏订单履约流程。

**要点二：** 消息消费幂等，通过分布式锁 + 状态前置校验实现。

**要点三：** 加分布式锁应该放在本地事务外，不能将加锁包裹在本地事务⾥。

**要点四：** 通过模板⽅法模式规范处理流程。

```
//消费订单物流配送结果消息
@Component
public class OrderWmsShipResultListener implements MessageListenerOrderly {
    @Autowired
    private RedisLock redisLock;

    @Autowired
    private OrderFulFillService orderFulFillService;

    @Override
    public ConsumeOrderlyStatus consumeMessage(List<MessageExt> list, ConsumeOrderlyContext consumeOrderlyContext) {
        OrderEvent orderEvent;
        try {
            for (MessageExt messageExt : list) {
                String message = new String(messageExt.getBody());
                log.info("received orderWmsShopResult  message:{}", message);
                orderEvent = JSONObject.parseObject(message, OrderEvent.class);
                //1.解析消息
                WmsShipDTO wmsShipDTO = buildWmsShip(orderEvent);
                //2.加分布式锁 + 里面的前置状态校验防止消息重复消费
                String key = RedisLockKeyConstants.ORDER_WMS_RESULT_KEY + wmsShipDTO.getOrderId();
                boolean lock = redisLock.lock(key);
                if (!lock) {
                    log.error("order has not acquired lock，cannot inform order wms result, orderId={}", wmsShipDTO.getOrderId());
                    throw new BaseBizException(OrderErrorCodeEnum.ORDER_NOT_ALLOW_INFORM_WMS_RESULT);
                }
                //3.通知订单物流结果
                //注意这里分布式锁加锁放在了本地事务外面
                try {
                    orderFulFillService.informOrderWmsShipResult(wmsShipDTO);
                } finally {
                    if (lock) {
                        redisLock.unlock(key);
                    }
                }
            }
            return ConsumeOrderlyStatus.SUCCESS;
        } catch (Exception e) {
            //处理业务逻辑失败！Suspend current queue a moment
            return ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT;
        }
    }

    private WmsShipDTO buildWmsShip(OrderEvent orderEvent) {
        String messageContent = JSONObject.toJSONString(orderEvent.getMessageContent());
        WmsShipDTO wmsShipDTO = new WmsShipDTO();
        wmsShipDTO.setStatusChange(orderEvent.getOrderStatusChange());
        if (OrderStatusChangeEnum.ORDER_OUT_STOCKED.equals(orderEvent.getOrderStatusChange())) {
            //订单已出库消息
            OrderOutStockWmsEvent outStockWmsEvent = JSONObject.parseObject(messageContent, OrderOutStockWmsEvent.class);
            BeanCopierUtil.copyProperties(outStockWmsEvent, wmsShipDTO);
        } else if (OrderStatusChangeEnum.ORDER_DELIVERED.equals(orderEvent.getOrderStatusChange())) {
            //订单已配送消息
            OrderDeliveredWmsEvent deliveredWmsEvent = JSONObject.parseObject(messageContent, OrderDeliveredWmsEvent.class);
            BeanCopierUtil.copyProperties(deliveredWmsEvent, wmsShipDTO);
        } else if (OrderStatusChangeEnum.ORDER_SIGNED.equals(orderEvent.getOrderStatusChange())) {
            //订单已签收消息
            OrderSignedWmsEvent signedWmsEvent = JSONObject.parseObject(messageContent, OrderSignedWmsEvent.class);
            BeanCopierUtil.copyProperties(signedWmsEvent, wmsShipDTO);
        }
        return wmsShipDTO;
    }
}

@Service
public class OrderFulFillServiceImpl implements OrderFulFillService {
    @Autowired
    private SpringApplicationContext springApplicationContext;
    ...

    @Override
    public void informOrderWmsShipResult(WmsShipDTO wmsShipDTO) throws OrderBizException {
        //1.获取对应的订单物流结果处理器
        OrderWmsShipResultProcessor processor = getProcessor(wmsShipDTO.getStatusChange());
        //2.执行
        if (null != processor) {
            processor.execute(wmsShipDTO);
        }
    }

    //获取对应的订单物流结果处理器
    private OrderWmsShipResultProcessor getProcessor(OrderStatusChangeEnum orderStatusChange) {
        if (OrderStatusChangeEnum.ORDER_OUT_STOCKED.equals(orderStatusChange)) {
            return springApplicationContext.getBean(OrderOutStockedProcessor.class);
        } else if (OrderStatusChangeEnum.ORDER_DELIVERED.equals(orderStatusChange)) {
            return springApplicationContext.getBean(OrderDeliveredProcessor.class);
        } else if (OrderStatusChangeEnum.ORDER_SIGNED.equals(orderStatusChange)) {
            return springApplicationContext.getBean(OrderSignedProcessor.class);
        }
        return null;
    }
    ...
}

//Spring IOC容器组件
public class SpringApplicationContext {
    //Spring容器
    private ApplicationContext context;

    //构造函数
    public SpringApplicationContext(ApplicationContext context) {
        this.context = context;
    }

    //获取bean
    public <T> T getBean(Class<? extends T> clazz) {
        return context.getBean(clazz);
    }
}

@Configuration
@Import(value = {WebConfiguration.class, RedisConfig.class, SpringApplicationContext.class})
public class CommonAutoConfiguration {
}

public abstract class AbstractWmsShipResultProcessor implements OrderWmsShipResultProcessor {
    ...
    @Transactional(rollbackFor = Exception.class)
    @Override
    public void execute(WmsShipDTO wmsShipDTO) throws OrderBizException {
        //1.查询订单
        OrderInfoDO order = orderInfoDAO.getByOrderId(wmsShipDTO.getOrderId());
        if (null == order) {
            return;
        }
        //2.校验订单状态
        if (!checkOrderStatus(order)) {
            return;
        }
        //3.执行具体的业务逻辑
        doExecute(wmsShipDTO, order);
        //4.更新订单状态
        changeOrderStatus(order, wmsShipDTO);
        //5.增加操作日志
        saveOrderOperateLog(order, wmsShipDTO);
    }
    ...
}

//订单已签收物流结果处理器
@Component
public class OrderSignedProcessor extends AbstractWmsShipResultProcessor {
    @Autowired
    private OrderDeliveryDetailDAO orderDeliveryDetailDAO;

    @Override
    protected boolean checkOrderStatus(OrderInfoDO order) throws OrderBizException {
        OrderStatusEnum orderStatus = OrderStatusEnum.getByCode(order.getOrderStatus());
        if (!OrderStatusEnum.DELIVERY.equals(orderStatus)) {
            return false;
        }
        return true;
    }

    @Override
    protected void doExecute(WmsShipDTO wmsShipDTO, OrderInfoDO order) {
        //增加订单配送表的签收时间
        OrderDeliveryDetailDO deliveryDetail = orderDeliveryDetailDAO.getByOrderId(order.getOrderId());
        orderDeliveryDetailDAO.updateSignedTime(deliveryDetail.getId(), wmsShipDTO.getSignedTime());
    }
}
```

<br>

**(9)删除订单接口**

**一.业务规则**

删除是软删除，删除后⽤户不可查询，而且只有签收后才可以删除。

<br>

**二.具体实现**

步骤一：对参数orderIds进⾏⻓度校验，⻓度超过200，直接直接抛异常

步骤二：根据orderIds查询出来⼀批订单

步骤三：接着对每笔订单进⾏校验，校验是否是签收后状态(60,70,200)，如果不是，则直接抛异常

步骤四：对查询出来每次订单进⾏删除操作，将其deleteStatus字段设置为"1-已删除"

步骤五：构造返参，返回给调⽤⽅

<img width="100%" height="100%" alt="image" src="https://github.com/user-attachments/assets/7aa90f3c-43bf-4aac-9543-5e1ad72ebeda" />

```
@Service
public class OrderServiceImpl implements OrderService {
    ...
    //删除订单
    @Override
    public boolean removeOrders(List<String> orderIds) {
        //1.根据id查询订单
        List<OrderInfoDO> orders = orderInfoDAO.listByOrderIds(orderIds);
        if (CollectionUtils.isEmpty(orders)) {
            return true;
        }

        //2.校验订单是否可以移除
        orders.forEach(order -> {
            if (!canRemove(order)) {
                throw new OrderBizException(OrderErrorCodeEnum.ORDER_CANNOT_REMOVE);
            }
        });

        //3.对订单进行软删除
        List<Long> ids = orders.stream().map(OrderInfoDO::getId).collect(Collectors.toList());
        orderInfoDAO.softRemoveOrders(ids);
        return true;
    }
    ...
}
```

<br>

**(10)修改配送地址接口**

**一.业务规则**

订单只有还未出库时才可以修改地址，并且只可以修改⼀次。

<br>

**二.具体实现**

步骤一：根据orderId查询出⼀笔订单出来，如果查询为null，直接抛异常

步骤二：接着查询order_delivery_detail，如果查询为null，直接抛异常

步骤三：校验是否已修改过，如果是则直接抛异常

步骤四：校验订单是否还未出库(10,20,30)，如果已出库，直接抛异常

步骤五：进⾏具体的业务逻辑，更新order_delivery_detail中的地址信息

步骤六：构造返参，返回给调⽤⽅

<img width="100%" height="100%" alt="image" src="https://github.com/user-attachments/assets/60c81ba4-7aca-4e09-8472-5d2a2cb50fb7" />

```
@Service
public class OrderServiceImpl implements OrderService {
    ...
    //修改配送地址
    @Override
    public boolean adjustDeliveryAddress(AdjustDeliveryAddressRequest request) {
        //1.根据id查询订单
        OrderInfoDO order = orderInfoDAO.getByOrderId(request.getOrderId());
        ParamCheckUtil.checkObjectNonNull(order, OrderErrorCodeEnum.ORDER_NOT_FOUND);

        //2.校验订单是否未出库
        if (!OrderStatusEnum.unOutStockStatus().contains(order.getOrderStatus())) {
            throw new OrderBizException(OrderErrorCodeEnum.ORDER_NOT_ALLOW_TO_ADJUST_ADDRESS);
        }

        //3.查询订单配送信息
        OrderDeliveryDetailDO orderDeliveryDetail = orderDeliveryDetailDAO.getByOrderId(request.getOrderId());
        if (null == orderDeliveryDetail) {
            throw new OrderBizException(OrderErrorCodeEnum.ORDER_DELIVERY_NOT_FOUND);
        }
 
        //4.校验配送信息是否已经被修改过一次
        if (orderDeliveryDetail.getModifyAddressCount() > 0) {
            throw new OrderBizException(OrderErrorCodeEnum.ORDER_DELIVERY_ADDRESS_HAS_BEEN_ADJUSTED);
        }

        //5.更新配送地址信息
        orderDeliveryDetailDAO.updateDeliveryAddress(orderDeliveryDetail.getId(), orderDeliveryDetail.getModifyAddressCount(), request);
        return true;
    }
    ...
}

//调整订单配送地址
@NoArgsConstructor
@Data
public class AdjustDeliveryAddressRequest extends AbstractObject implements Serializable {
    private String orderId;//订单id
    private String province;//省
    private String city;//市
    private String area;//区    
    private String street;//街道地址
    private String detailAddress;//详细地址
    private BigDecimal lon;//经度
    private BigDecimal lat;//纬度
}
```

<br>

**(11)查询订单列表接口**

**一.业务规则**

⽆效状态(255)订单不展示。

<br>

**二.字段映射梳理**

```
1.⼊参和表字段映射关系梳理
业务线：businessIdentifier -> order_info.business_identifier
订单类型：orderTypes -> order_info.order_type
订单号：orderIds -> order_info.order_id
卖家ID：sellerIds -> order_info.seller_id
⽗订单号：parentOrderIds -> order_info.parent_order_id
订单状态：orderStatus -> order_info.order_status
创建时间-开始/截⽌：startCreatedTime，endCreatedTime -> order_info.gmt_create
⽀付时间-开始/截⽌：startPayTime，endPayTime -> order_info.pay_time
⽤户ID：userIds -> order_info.user_id
⽀付⾦额-区间开始/区间截⽌：startPayAmount，endPayAmount -> order_info.pay_amount
sku code：skuCodes -> order_item.sku_code
sku商品名称：productNames -> order_item.product_name
收货⼈⼿机号：receiverPhones -> order_delivery_detail.receiver_phone
收货⼈姓名：receiverPhones -> order_delivery_detail.receiver_name
交易流⽔号：tradeNos -> order_payment_detail.out_trade_no
下单平台：orderPlatforms -> order_channel.platform

2.返回结果和数据表字段映射关系梳理
业务线：businessIdentifier -> order_info.business_identifier
订单号：orderId -> order_info.order_id
卖家ID：sellerId -> order_info.seller_id
⽤户ID：userId -> order_info.user_id
接⼊⽅订单ID：businessOrderId -> order_info.business_order_id
⽗订单号：parentOrderId -> order_info.parent_order_id
订单状态：orderStatus -> order_info.order_status
⽀付⽅式：payTyoe -> order_info.pay_type
⽀付时间：payTime -> order_info.pay_time
优惠券：ID -> order_info.coupon_id
⽤户备注：userRemark -> order_info.user_remark
订单评论状态：commentStatus -> order_info.comment_status
商品图⽚：productImg -> order_item.product_img
商品名称：productName -> order_item.product_name
sku code：skuCode -> order_item.sku_code
销售数量：saleQuantity -> order_item.sale_quantity
⽀付⾦额：payAmount -> order_item.pay_amount
```

<br>

**三.具体实现**

步骤一：组装业务查询规则，通过Builder模式构建

步骤二：连表分⻚查询order_info、order_item、order_delivery_detail、order_payment_detail，具体字段映射参考上述⼊参和表字段映射关系梳理

步骤三：如果没给排序字段，默认按创建时间降序

步骤四：对于查询出来的每条记录，需要查询对应的数据表。然后根据上述返回结果和数据表字段映射关系梳理，组装返参，返回给调⽤⽅

```
//订单中心-订单查询业务接口
@DubboService(version = "1.0.0", interfaceClass = OrderQueryApi.class)
public class OrderQueryApiImpl implements OrderQueryApi {
    @Autowired
    private OrderQueryService orderQueryService;

    //查询订单列表
    @Override
    public JsonResult<PagingInfo<OrderListDTO>> listOrders(OrderQuery query) {
        try {
            //1.参数校验
            orderQueryService.checkQueryParam(query);
            //2.查询
            return JsonResult.buildSuccess(orderQueryService.executeListQuery(query));
        } catch (OrderBizException e) {
            log.error("biz error", e);
            return JsonResult.buildError(e.getErrorCode(), e.getErrorMsg());
        } catch (Exception e) {
            log.error("error", e);
            return JsonResult.buildError(e.getMessage());
        }
    }
    ...
}

//订单列表查询请求
@Data
public class OrderQuery extends AbstractObject implements Serializable {
    public static final Integer MAX_PAGE_SIZE = 100;
    private Integer businessIdentifier;//业务线
    private Set<Integer> orderTypes;//订单类型
    private Set<String> orderIds;//订单号
    private Set<String> sellerIds;//卖家ID
    private Set<String> parentOrderIds;//父订单号
    private Set<String> userIds;//用户ID
    private Set<Integer> orderStatus;//订单状态
    private Set<String> receiverPhones;//收货人手机号
    private Set<String> receiverNames;//收货人姓名
    private Set<String> tradeNos;//交易流水号
    private Set<String> skuCodes;//sku code
    private Set<String> productNames;//sku商品名称
    private Pair<Date, Date> createdTimeInterval;//创建时间-查询区间
    private Pair<Date, Date> payTimeInterval;//支付时间-查询区间
    private Pair<Integer, Integer> payAmountInterval;//支付金额-查询区间
    private Integer pageNo = 1;//页码
    private Integer pageSize = 20;//每页条数
}

//订单列表DTO
@Data
public class OrderListDTO extends AbstractObject implements Serializable {
    private Integer businessIdentifier;//接入方业务线标识
    private String orderId;//订单编号
    private String parentOrderId;//父订单编号
    private String businessOrderId;//接入方订单号
    private Integer orderType;//订单类型
    private Integer orderStatus;//订单状态
    private String sellerId;//卖家编号
    private String userId;//买家编号
    private Integer payType;//支付方式
    private String couponId;//使用的优惠券编号
    private Date payTime;//支付时间
    private String userRemark;//用户备注
    private Integer commentStatus;//订单评论状态 0:未发表评论  1:已发表评论
    private String productImg;//商品图片
    private String productName;//商品名称
    private String skuCode;//sku编码
    private Integer saleQuantity;//销售数量
    private Integer payAmount;//交易支付金额
}

@Service
public class OrderQueryServiceImpl implements OrderQueryService {
    ...
    //执行列表查询
    @Override
    public PagingInfo<OrderListDTO> executeListQuery(OrderQuery query) {
        //1.组装业务查询规则
        OrderListQueryDTO queryDTO = OrderListQueryDTO.Builder.builder()
            .copy(query)
            .removeInValidStatus()//不展示无效订单
            .setPage(query)
            .build();
        //2.查询 TODO 采用接入ES进行优化查询的性能
        Page<OrderListDTO> page = orderInfoDAO.listByPage(queryDTO);
        //3.转化
        return PagingInfo.toResponse(page.getRecords(), page.getTotal(), (int) page.getCurrent(), (int) page.getSize());
    }
    ...
}

//订单列表查询入参DTO
@Data
public class OrderListQueryDTO extends AbstractObject {
    private Integer businessIdentifier;//业务线
    private Set<Integer> orderTypes;//订单类型
    private Set<String> orderIds;//订单号
    private Set<String> sellerIds;//卖家ID
    private Set<String> parentOrderIds;//父订单号
    private Set<String> userIds;//用户ID
    private Set<Integer> orderStatus;//订单状态
    private Set<String> receiverPhones;//收货人手机号
    private Set<String> receiverNames;//收货人姓名
    private Set<String> tradeNos;//交易流水号
    private Set<String> skuCodes;//sku code
    private Set<String> productNames;//sku商品名称
    private Pair<Date, Date> createdTimeInterval;//创建时间-查询区间
    private Pair<Date, Date> payTimeInterval;//支付时间-查询区间
    private Pair<Integer, Integer> payAmountInterval;//支付金额-查询区间
    private Integer pageNo = 1;//页码
    private Integer pageSize = 20;//每页条数

    //内部构造器
    public static class Builder {
        private OrderListQueryDTO query = null;

        public static Builder builder() {
            return new Builder();
        }

        public Builder copy(OrderQuery orderQuery) {
            query = orderQuery.clone(OrderListQueryDTO.class);
            return this;
        }

        //不展示无效订单
        public Builder removeInValidStatus() {
            if (CollectionUtils.isEmpty(query.getOrderStatus())) {
                query.setOrderStatus(OrderStatusEnum.validStatus());
            }
            return this;
        }

        //设置分页
        public Builder setPage(OrderQuery orderQuery) {
            query.setPageNo(orderQuery.getPageNo());
            query.setPageSize(orderQuery.getPageSize());
            return this;
        }

        public OrderListQueryDTO build() {
            return query;
        }
    }
}
```

<br>

**(12)查询订单详情接口**

**一.业务规则**

除了展示正向订单相关信息外，还需展示缺品时退单的⾦额信息(售后单)。

<br>

**二.字段映射梳理**

```
OrderDetailDTO                                        表 
OrderInfoDTO orderInfo                           order_info 
List<OrderItemDTO> orderItems                    order_item 
List<OrderAmountDetailDTO> orderAmountDetails    order_amount_detail 
List<OrderPaymentDetailDTO> orderPaymentDetails  order_payment_detail 
OrderDeliveryDetailDTO orderDeliveryDetail       order_delivery_detail 
Map<Integer, Integer> orderAmountMap             order_amount 
List<OrderOperateLogDTO> orderOperateLogs        order_operate_log 
List<OrderSnapshotDTO> orderSnapshot             order_snapshot 
List<OrderLackItemDTO> lackItems                 after_sale_info,after_sale_item
```

<br>

**三.具体实现**

步骤一：根据orderId查询order_info表记录

步骤二：如果查询为null，直接返回null

步骤三：如果能查询到orderInfo记录，那么根据字段映射梳理，组装返参

步骤四：缺品标识存储在order_info.ext_json字段

```
//订单中心-订单查询业务接口
@DubboService(version = "1.0.0", interfaceClass = OrderQueryApi.class)
public class OrderQueryApiImpl implements OrderQueryApi {
    @Autowired
    private OrderQueryService orderQueryService;
    ...

    //查询订单详情
    @Override
    public JsonResult<OrderDetailDTO> orderDetail(String orderId) {
        try {
            //1.参数校验
            ParamCheckUtil.checkStringNonEmpty(orderId, OrderErrorCodeEnum.ORDER_ID_IS_NULL);
            //2.查询
            return JsonResult.buildSuccess(orderQueryService.orderDetail(orderId));
        } catch (OrderBizException e) {
            log.error("biz error", e);
            return JsonResult.buildError(e.getErrorCode(), e.getErrorMsg());
        } catch (Exception e) {
            log.error("error", e);
            return JsonResult.buildError(e.getMessage());
        }
    }
}

@Service
public class OrderQueryServiceImpl implements OrderQueryService {
    ...
    //查询订单详情
    @Override
    public OrderDetailDTO orderDetail(String orderId) {
        //1.查询订单
        OrderInfoDO orderInfo = orderInfoDAO.getByOrderId(orderId);
        if (null == orderInfo) {
            return null;
        }
        //2.查询订单条目
        List<OrderItemDO> orderItems = orderItemDAO.listByOrderId(orderId);
        //3.查询订单费用明细
        List<OrderAmountDetailDO> orderAmountDetails = orderAmountDetailDAO.listByOrderId(orderId);
        //4.查询订单配送信息
        OrderDeliveryDetailDO orderAmountDetail = orderDeliveryDetailDAO.getByOrderId(orderId);
        //5.查询订单支付明细
        List<OrderPaymentDetailDO> orderPaymentDetails = orderPaymentDetailDAO.listByOrderId(orderId);
        //6.查询订单费用类型
        List<OrderAmountDO> orderAmounts = orderAmountDAO.listByOrderId(orderId);
        //7.查询订单操作日志
        List<OrderOperateLogDO> orderOperateLogs = orderOperateLogDAO.listByOrderId(orderId);
        //8.查询订单快照
        List<OrderSnapshotDO> orderSnapshots = orderSnapshotDAO.listByOrderId(orderId);
        //9.查询缺品退款信息
        List<OrderLackItemDTO> lackItems = null;
        if (isLack(orderInfo)) {
            lackItems = afterSaleQueryService.getOrderLackItemInfo(orderId);
        }
        //10.构造返参
        return new OrderDetailBuilder()
            .orderInfo(orderInfo)
            .orderItems(orderItems)
            .orderAmountDetails(orderAmountDetails)
            .orderDeliveryDetail(orderAmountDetail)
            .orderPaymentDetails(orderPaymentDetails)
            .orderAmounts(orderAmounts)
            .orderOperateLogs(orderOperateLogs)
            .orderSnapshots(orderSnapshots)
            .lackItems(lackItems)
            .build();
    }
    ...
}

//订单详情DTO
@Data
public class OrderDetailDTO {
    private OrderInfoDTO orderInfo;//订单
    private List<OrderItemDTO> orderItems;//订单条目
    private List<OrderAmountDetailDTO> orderAmountDetails;//订单费用明细
    private OrderDeliveryDetailDTO orderDeliveryDetail;//订单配送信息表
    private List<OrderPaymentDetailDTO> orderPaymentDetails;//订单支付明细
    private Map<Integer, Integer> orderAmounts;//费用类型
    private List<OrderOperateLogDTO> orderOperateLogs;//订单操作日志
    private List<OrderSnapshotDTO> orderSnapshots;//订单快照信息
    private List<OrderLackItemDTO> lackItems;//订单缺品信息
}

//订单详情构造器
public class OrderDetailBuilder {
    private OrderDetailDTO orderDetail = new OrderDetailDTO();

    public OrderDetailBuilder orderInfo(OrderInfoDO orderInfoDO) {
        if (null != orderInfoDO) {
            orderDetail.setOrderInfo(orderInfoDO.clone(OrderInfoDTO.class));
        }
        return this;
    }

    public OrderDetailBuilder orderItems(List<OrderItemDO> orderItems) {
        if (CollectionUtils.isNotEmpty(orderItems)) {
            orderDetail.setOrderItems(ObjectUtil.convertList(orderItems, OrderItemDTO.class));
        }
        return this;
    }

    public OrderDetailBuilder orderAmountDetails(List<OrderAmountDetailDO> orderAmountDetails) {
        if (CollectionUtils.isNotEmpty(orderAmountDetails)) {
            orderDetail.setOrderAmountDetails(ObjectUtil.convertList(orderAmountDetails, OrderAmountDetailDTO.class));
        }
        return this;
    }

    public OrderDetailBuilder orderDeliveryDetail(OrderDeliveryDetailDO orderDeliveryDetail) {
        if (null != orderDeliveryDetail) {
            orderDetail.setOrderDeliveryDetail(orderDeliveryDetail.clone(OrderDeliveryDetailDTO.class));
        }
        return this;
    }

    public OrderDetailBuilder orderPaymentDetails(List<OrderPaymentDetailDO> orderPaymentDetails) {
        if (CollectionUtils.isNotEmpty(orderPaymentDetails)) {
            orderDetail.setOrderPaymentDetails(ObjectUtil.convertList(orderPaymentDetails, OrderPaymentDetailDTO.class));
        }
        return this;
    }

    public OrderDetailBuilder orderAmounts(List<OrderAmountDO> orderAmounts) {
        if (CollectionUtils.isNotEmpty(orderAmounts)) {
            orderDetail.setOrderAmounts(orderAmounts.stream().collect(Collectors.toMap(OrderAmountDO::getAmountType, OrderAmountDO::getAmount, (v1, v2) -> v1)));
        }
        return this;
    }

    public OrderDetailBuilder orderOperateLogs(List<OrderOperateLogDO> orderOperateLogs) {
        if (CollectionUtils.isNotEmpty(orderOperateLogs)) {
            orderDetail.setOrderOperateLogs(ObjectUtil.convertList(orderOperateLogs, OrderOperateLogDTO.class));
        }
        return this;
    }

    public OrderDetailBuilder orderSnapshots(List<OrderSnapshotDO> orderSnapshots) {
        if (CollectionUtils.isNotEmpty(orderSnapshots)) {
            orderDetail.setOrderSnapshots(ObjectUtil.convertList(orderSnapshots, OrderSnapshotDTO.class));
        }
        return this;
    }

    public OrderDetailBuilder lackItems(List<OrderLackItemDTO> lackItems) {
        orderDetail.setLackItems(lackItems);
        return this;
    }

    public OrderDetailDTO build() {
        return orderDetail;
    }
}
```

<br>

**4.逆向售后业务接口**

**(1)取消订单/超时未支付取消接口**

**(2)支付退款回调接口**

**(3)处理售后申请接口**

**(4)客服审核售后接口**

**(5)缺品接口**

**(6)用户撤销售后申请**

**(7)自动取消超时订单任务接口**

**(8)查询售后列表接口**

**(9)查询售后详情接口**

<br>

**(1)取消订单/超时未支付取消接口**

**一.使用场景**

**场景一：** ⽤户⼿动取消，订单出库状态前都可取消

**场景二：** 正向⽣单后，会延迟30分钟发送订单消息到MQ。30分钟后消费到该MQ消息时，若仍未⽀付则取消该订单

**场景三：** 定时任务扫描，超过30分钟未⽀付才取消

<img width="100%" height="100%" alt="image" src="https://github.com/user-attachments/assets/ae1fcc9d-4b45-4558-8cfa-6a467baf6c00" />

<br>

**二.具体实现**

<img width="100%" height="100%" alt="image" src="https://github.com/user-attachments/assets/3195492f-c4a0-48d5-8438-90ec74458ee2" />

<br>

**三.技术要点**

**要点一：** 更新订单状态、取消履约、发送释放资产的消息到MQ是⼀个分布式事务，⽬前使⽤Seata分布式事务框架来解决。

**要点二：** 超时订单处理⽅案是⽣成订单后发送⼀个延迟消息，延迟30分钟后才推送给消费者被消费。订单系统在消费该延迟消息时，会验证订单是否已支付，否就调⽤取消订单的接⼝。

<br>

**关于取消订单的处理：**

```
//订单中心-逆向售后业务接口
@DubboService(version = "1.0.0", interfaceClass = AfterSaleApi.class, retries = 0)
public class AfterSaleApiImpl implements AfterSaleApi {
    @Autowired
    private OrderLackService orderLackItemService;

    @Autowired
    private OrderAfterSaleService orderAfterSaleService;

    //取消订单/超时未支付取消
    @Override
    public JsonResult<Boolean> cancelOrder(CancelOrderRequest cancelOrderRequest) {
        try {
            return orderAfterSaleService.cancelOrder(cancelOrderRequest);
        } catch (OrderBizException e) {
            log.error("biz error", e);
            return JsonResult.buildError(e.getErrorCode(), e.getErrorMsg());
        } catch (Exception e) {
            log.error("system error", e);
            return JsonResult.buildError(e.getMessage());
        }
    }
    ...
}

//取消订单入参
@Data
public class CancelOrderRequest extends AbstractObject implements Serializable {
    private static final long serialVersionUID = -4035579903997700971L;
    private String orderId;//订单号
    private Integer businessIdentifier;//订单渠道来源
    private Integer cancelType;//订单取消类型 0-手动取消 1-超时未支付
    private String userId;//用户id
    private Integer orderType;//订单类型
    private Integer orderStatus;//订单状态
    private Integer oldOrderStatus;//原订单状态
}

@Service
public class OrderAfterSaleServiceImpl implements OrderAfterSaleService {
    ...
    //取消订单/超时未支付取消
    @Override
    public JsonResult<Boolean> cancelOrder(CancelOrderRequest cancelOrderRequest) {
        //入参检查
        checkCancelOrderRequestParam(cancelOrderRequest);
        //分布式锁
        String orderId = cancelOrderRequest.getOrderId();
        String key = RedisLockKeyConstants.CANCEL_KEY + orderId;
        try {
            boolean lock = redisLock.lock(key);
            if (!lock) {
                throw new OrderBizException(OrderErrorCodeEnum.CANCEL_ORDER_REPEAT);
            }
            //执行取消订单
            executeCancelOrder(cancelOrderRequest, orderId);
            return JsonResult.buildSuccess(true);
        } catch (Exception e) {
            throw new OrderBizException(e.getMessage());
        } finally {
            redisLock.unlock(key);
        }
    }

    @Override
    @GlobalTransactional(rollbackFor = Exception.class)
    public void executeCancelOrder(CancelOrderRequest cancelOrderRequest, String orderId) {
        //1.组装数据
        CancelOrderAssembleRequest cancelOrderAssembleRequest = buildAssembleRequest(orderId, cancelOrderRequest);
        //幂等校验：防止多个线程同时操作取消同一笔订单
        if (OrderStatusEnum.CANCELED.getCode().equals(cancelOrderAssembleRequest.getOrderInfoDTO().getOrderStatus())) {
            return;
        }
        //2.检验订单支付状态
        checkOrderPayStatus(cancelOrderAssembleRequest);
        //3.更新订单状态和记录订单操作日志
        updateOrderStatusAndSaveOperationLog(cancelOrderAssembleRequest);
        //超时未支付的订单不用继续再往下执行取消履约和释放资产
        if (OrderStatusEnum.PAID.getCode() > cancelOrderAssembleRequest.getOrderInfoDTO().getOrderStatus()) {
            return;
        }
        //4.履约取消
        cancelFulfill(cancelOrderAssembleRequest);
        //5.发送释放资产消息到MQ
        defaultProducer.sendMessage(RocketMqConstant.RELEASE_ASSETS_TOPIC, JSONObject.toJSONString(cancelOrderAssembleRequest), "释放资产");
    }
    ...
}

//消费MQ的释放资产消息
@Component
public class ReleaseAssetsListener implements MessageListenerConcurrently {
    @Autowired
    private DefaultProducer defaultProducer;

    @Autowired
    private OrderItemDAO orderItemDAO;

    @Override
    public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> list, ConsumeConcurrentlyContext consumeConcurrentlyContext) {
        try {
            for (MessageExt messageExt : list) {
                String message = new String(messageExt.getBody());
                log.info("ReleaseAssetsConsumer message:{}", message);
                CancelOrderAssembleRequest cancelOrderAssembleRequest = JSONObject.parseObject(message, CancelOrderAssembleRequest.class);
                //发送取消订单退款请求消息到MQ
                defaultProducer.sendMessage(RocketMqConstant.CANCEL_REFUND_REQUEST_TOPIC, JSONObject.toJSONString(cancelOrderAssembleRequest), "取消订单退款");
                //发送释放库存消息到MQ
                OrderInfoDTO orderInfoDTO = cancelOrderAssembleRequest.getOrderInfoDTO();
                CancelOrderReleaseProductStockRequest cancelOrderReleaseProductStockRequest = buildSkuList(orderInfoDTO, orderItemDAO);
                defaultProducer.sendMessage(RocketMqConstant.CANCEL_RELEASE_INVENTORY_TOPIC, JSONObject.toJSONString(cancelOrderReleaseProductStockRequest), "取消订单释放库存");
                //发送释放优惠券消息到MQ
                CancelOrderReleaseUserCouponRequest cancelOrderReleaseUserCouponRequest = orderInfoDTO.clone(CancelOrderReleaseUserCouponRequest.class);
                defaultProducer.sendMessage(RocketMqConstant.CANCEL_RELEASE_PROPERTY_TOPIC, JSONObject.toJSONString(cancelOrderReleaseUserCouponRequest), "取消订单释放优惠券");
            }
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
        } catch (Exception e) {
            log.error("consumer error", e);
            return ConsumeConcurrentlyStatus.RECONSUME_LATER;
        }
    }
    ...
}

//消费取消订单退款请求的消息
@Component
public class CancelRefundListener implements MessageListenerConcurrently {
    @Autowired
    private OrderAfterSaleService orderAfterSaleService;

    @Override
    public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> list, ConsumeConcurrentlyContext consumeConcurrentlyContext) {
        try {
            for (MessageExt messageExt : list) {
                String message = new String(messageExt.getBody());
                CancelOrderAssembleRequest cancelOrderAssembleRequest = JSONObject.parseObject(message, CancelOrderAssembleRequest.class);
                log.info("CancelRefundConsumer message:{}", message);
                //执行 取消订单/超时未支付取消 前的操作
                JsonResult<Boolean> jsonResult = orderAfterSaleService.processCancelOrder(cancelOrderAssembleRequest);
                if (!jsonResult.getSuccess()) {
                    throw new OrderBizException(OrderErrorCodeEnum.CONSUME_MQ_FAILED);
                }
            }
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
        } catch (Exception e) {
            log.error("consumer error", e);
            return ConsumeConcurrentlyStatus.RECONSUME_LATER;
        }
    }
}

//消费释放库存的消息
@Component
public class ReleaseInventoryListener implements MessageListenerConcurrently {
    @DubboReference(version = "1.0.0")
    private InventoryApi inventoryApi;

    @Override
    public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> list, ConsumeConcurrentlyContext consumeConcurrentlyContext) {
        try {
            for (MessageExt msg : list) {
                String content = new String(msg.getBody(), StandardCharsets.UTF_8);
                log.info("ReleaseInventoryConsumer message:{}", content);
                CancelOrderReleaseProductStockRequest cancelOrderReleaseProductStockRequest = JSONObject.parseObject(content, CancelOrderReleaseProductStockRequest.class);
                JsonResult<Boolean> jsonResult = inventoryApi.cancelOrderReleaseProductStock(cancelOrderReleaseProductStockRequest);
                if (!jsonResult.getSuccess()) {
                    throw new InventoryBizException(InventoryErrorCodeEnum.CONSUME_MQ_FAILED);
                }
            }
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
        } catch (Exception e) {
            log.error("consumer error", e);
            return ConsumeConcurrentlyStatus.RECONSUME_LATER;
        }
    }
}

//消费释放优惠券的消息
@Component
public class ReleasePropertyListener implements MessageListenerConcurrently {
    @DubboReference(version = "1.0.0")
    private MarketApi marketApi;

    @Override
    public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> list, ConsumeConcurrentlyContext consumeConcurrentlyContext) {
        try {
            for (MessageExt msg : list) {
                String content = new String(msg.getBody(), StandardCharsets.UTF_8);
                log.info("ReleasePropertyConsumer message:{}", content);
                CancelOrderReleaseUserCouponRequest cancelOrderReleaseUserCouponRequest = JSONObject.parseObject(content, CancelOrderReleaseUserCouponRequest.class);
                JsonResult<Boolean> jsonResult = marketApi.cancelOrderReleaseCoupon(cancelOrderReleaseUserCouponRequest);
                if (!jsonResult.getSuccess()) {
                    throw new MarketBizException(MarketErrorCodeEnum.CONSUME_MQ_FAILED);
                }
            }
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
        } catch (Exception e) {
            log.error("consumer error", e);
            return ConsumeConcurrentlyStatus.RECONSUME_LATER;
        }
    }
}
```

<br>

**关于退款的处理：**

```
@Service
public class OrderAfterSaleServiceImpl implements OrderAfterSaleService {
    ...
    @Override
    public JsonResult<Boolean> processCancelOrder(CancelOrderAssembleRequest cancelOrderAssembleRequest) {
        String orderId = cancelOrderAssembleRequest.getOrderId();
        //分布式锁
        String key = RedisLockKeyConstants.REFUND_KEY + orderId;
        try {
            boolean lock = redisLock.lock(key);
            if (!lock) {
                throw new OrderBizException(OrderErrorCodeEnum.PROCESS_REFUND_REPEAT);
            }
            //执行退款前的准备工作
            //1.计算取消订单退款金额
            CancelOrderRefundAmountDTO cancelOrderRefundAmountDTO = calculatingCancelOrderRefundAmount(cancelOrderAssembleRequest);
            cancelOrderAssembleRequest.setCancelOrderRefundAmountDTO(cancelOrderRefundAmountDTO);
            //2.取消订单操作记录售后信息
            insertCancelOrderAfterSale(cancelOrderAssembleRequest, AfterSaleStatusEnum.REVIEW_PASS.getCode());
            //3.发送退款MQ
            ActualRefundMessage actualRefundMessage = new ActualRefundMessage();
            actualRefundMessage.setAfterSaleRefundId(cancelOrderAssembleRequest.getAfterSaleRefundId());
            actualRefundMessage.setOrderId(cancelOrderAssembleRequest.getOrderId());
            actualRefundMessage.setLastReturnGoods(cancelOrderAssembleRequest.isLastReturnGoods());
            actualRefundMessage.setAfterSaleId(Long.valueOf(cancelOrderAssembleRequest.getAfterSaleId()));
            defaultProducer.sendMessage(RocketMqConstant.ACTUAL_REFUND_TOPIC, JSONObject.toJSONString(actualRefundMessage), "实际退款");
            return JsonResult.buildSuccess(true);
        } catch (Exception e) {
            log.error(e.getMessage());
            throw new OrderBizException(OrderErrorCodeEnum.PROCESS_REFUND_FAILED);
        } finally {
            redisLock.unlock(key);
        }
    }
    ...
}

//实际退款消费者
@Component
public class ActualRefundListener implements MessageListenerConcurrently {
    @Autowired
    private OrderAfterSaleService orderAfterSaleService;

    @Override
    public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> list, ConsumeConcurrentlyContext consumeConcurrentlyContext) {
        try {
            for (MessageExt messageExt : list) {
                String message = new String(messageExt.getBody());
                ActualRefundMessage actualRefundMessage = JSONObject.parseObject(message, ActualRefundMessage.class);
                log.info("ActualRefundConsumer message:{}", message);
                JsonResult<Boolean> jsonResult = orderAfterSaleService.refundMoney(actualRefundMessage);
                if (!jsonResult.getSuccess()) {
                    throw new OrderBizException(jsonResult.getErrorCode(), jsonResult.getErrorMessage());
                }
            }
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
        } catch (Exception e) {
            log.error("consumer error", e);
            return ConsumeConcurrentlyStatus.RECONSUME_LATER;
        }
    }
}

@Service
public class OrderAfterSaleServiceImpl implements OrderAfterSaleService {
    ...
    //执行退款
    @Override
    public JsonResult<Boolean> refundMoney(ActualRefundMessage actualRefundMessage) {
        Long afterSaleId = actualRefundMessage.getAfterSaleId();
        String key = RedisLockKeyConstants.REFUND_KEY + afterSaleId;
        try {
            boolean lock = redisLock.lock(key);
            if (!lock) {
                throw new OrderBizException(OrderErrorCodeEnum.REFUND_MONEY_REPEAT);
            }
            AfterSaleInfoDO afterSaleInfoDO = afterSaleInfoDAO.getOneByAfterSaleId(actualRefundMessage.getAfterSaleId());
            Long afterSaleRefundId = actualRefundMessage.getAfterSaleRefundId();
            AfterSaleRefundDO afterSaleRefundDO = afterSaleRefundDAO.getById(afterSaleRefundId);
            //1.封装调用支付退款接口的数据
            PayRefundRequest payRefundRequest = buildPayRefundRequest(actualRefundMessage, afterSaleRefundDO);
            //2.执行退款
            if (!payApi.executeRefund(payRefundRequest)) {
                throw new OrderBizException(OrderErrorCodeEnum.ORDER_REFUND_AMOUNT_FAILED);
            }
            //3.售后记录状态
            //执行退款更新售后信息
            updateAfterSaleStatus(afterSaleInfoDO, AfterSaleStatusEnum.REVIEW_PASS.getCode(), AfterSaleStatusEnum.REFUNDING.getCode());
            //4.退货的最后一笔退优惠券
            if (actualRefundMessage.isLastReturnGoods()) {
                //释放优惠券权益
                String orderId = actualRefundMessage.getOrderId();
                OrderInfoDO orderInfoDO = orderInfoDAO.getByOrderId(orderId);
                CancelOrderReleaseUserCouponRequest cancelOrderReleaseUserCouponRequest = orderInfoDO.clone(CancelOrderReleaseUserCouponRequest.class);
                defaultProducer.sendMessage(RocketMqConstant.CANCEL_RELEASE_PROPERTY_TOPIC, JSONObject.toJSONString(cancelOrderReleaseUserCouponRequest), "释放优惠券权益");
            }
            return JsonResult.buildSuccess(true);
        } catch (OrderBizException e) {
            log.error("system error", e);
            return JsonResult.buildError(e.getMessage());
        } finally {
            redisLock.unlock(key);
        }
    }
    ...
}
```

<br>

**(2)支付退款回调接口**

**一.使用场景**

⽤户⼿动取消订单后并发起退款，经过⼀段时间之后，⽀付系统回调给订单系统退款结果。

<br>

**二.具体实现**

<img width="100%" height="100%" alt="image" src="https://github.com/user-attachments/assets/5b63b3ff-1329-4613-aeae-e1f8ffb2526b" />

```
@Service
public class OrderAfterSaleServiceImpl implements OrderAfterSaleService {
    ...
    //取消订单支付退款的回调入口
    @Override
    @Transactional(rollbackFor = Exception.class)
    public JsonResult<Boolean> receivePaymentRefundCallback(RefundCallbackRequest payRefundCallbackRequest) {
        String afterSaleId = payRefundCallbackRequest.getAfterSaleId();
        String key = RedisLockKeyConstants.REFUND_KEY + afterSaleId;
        try {
            boolean lock = redisLock.lock(key);
            if (!lock) {
                throw new OrderBizException(OrderErrorCodeEnum.PROCESS_PAY_REFUND_CALLBACK_REPEAT);
            }
            //1.入参校验
            checkRefundCallbackParam(payRefundCallbackRequest);
            //2.获取三方支付退款的返回结果
            Integer afterSaleStatus;
            Integer refundStatus;
            String refundStatusMsg;
            if (RefundStatusEnum.REFUND_SUCCESS.getCode().equals(payRefundCallbackRequest.getRefundStatus())) {
                afterSaleStatus = AfterSaleStatusEnum.REFUNDED.getCode();
                refundStatus = RefundStatusEnum.REFUND_SUCCESS.getCode();
                refundStatusMsg = RefundStatusEnum.REFUND_SUCCESS.getMsg();
            } else {
                afterSaleStatus = AfterSaleStatusEnum.FAILED.getCode();
                refundStatus = RefundStatusEnum.REFUND_FAIL.getCode();
                refundStatusMsg = RefundStatusEnum.REFUND_FAIL.getMsg();
            }
            //3.更新售后记录，支付退款回调更新售后信息
            updatePaymentRefundCallbackAfterSale(payRefundCallbackRequest, afterSaleStatus, refundStatus, refundStatusMsg);
            //4.发短信
            orderAfterSaleService.sendRefundMobileMessage(afterSaleId);
            //5.发APP通知
            orderAfterSaleService.sendRefundAppMessage(afterSaleId);
            return JsonResult.buildSuccess();
        } catch (Exception e) {
            log.error(e.getMessage());
            throw new OrderBizException(OrderErrorCodeEnum.PROCESS_PAY_REFUND_CALLBACK_FAILED);
        } finally {
            redisLock.unlock(key);
        }
    }
    ...
}

//支付系统退款回调入参
@Data
public class RefundCallbackRequest extends AbstractObject implements Serializable {
    private static final long serialVersionUID = -5258136513569055820L;
    private String orderId;//订单号
    private String batchNo;//退款批次号
    private Integer refundStatus;//支付接口返回来的退款结果状态：10 未退款  20 退款成功 30 退款失败
    private Integer refundFee;//退款费用
    private Integer totalFee;//退款总额
    private String sign;//支付退款签名
    private String tradeNo;//交易流水号
    private Date refundTime;//支付退款回调时间
    private String afterSaleId;//订单售后id
}
```

<br>

**(3)处理售后申请接口**

**一.使用场景**

售后申请接收的是⽤户发起的退货请求，退货分整笔退和单笔退。

⽬前订单格式：⼀笔订单对应多个条⽬。系统仅⽀持默认每次退货是退⼀个条⽬，不考虑退某条目部分数量的场景。例如⼀笔订单包含两个条⽬，A条⽬商品数量是2，B条⽬商品数量是1。⽤户退货每次只退⼀个。如果退A，不考虑A的商品数量，默认就是全退。如果退B，同理。如果已经先退掉了A，再次退B时发现本次退完之后，该笔订单的全部条⽬都已经退掉，则在B中补退运费，在B退成功以后回退给⽤户优惠券。

⽬前此业务场景的缺陷：不⽀持部分退、拆单退，⽬前判断是否是退货最后⼀单的逻辑⽐较简单。最后⼀笔退货补退运费时，没有⽣成运费的售后单。以上述例⼦为例：先退掉A，⽣成⼀笔售后单，记录的实际退款⾦额是A的退款⾦额。再退掉B，此时B的实际退款⾦额 = 运费 + B的退款⾦额，⽣成⼀笔售后单。改造点：单独再⽣成⼀张运费的售后单。

<br>

**二.具体实现**

<img width="100%" height="100%" alt="image" src="https://github.com/user-attachments/assets/509b7d51-fa9e-4ec0-90de-7e95a916b092" />

```
@RestController
@RequestMapping("/afterSale")
public class AfterSaleController {
    @Autowired
    private OrderAfterSaleService orderAfterSaleService;

    @Autowired
    private RedisLock redisLock;
    ...

    //用户发起退货售后
    @PostMapping("/applyAfterSale")
    public JsonResult<Boolean> applyAfterSale(@RequestBody ReturnGoodsOrderRequest returnGoodsOrderRequest) {
        //分布式锁
        String orderId = returnGoodsOrderRequest.getOrderId();
        String key = RedisLockKeyConstants.REFUND_KEY + orderId;
        boolean lock = redisLock.lock(key);
        if (!lock) {
            throw new OrderBizException(OrderErrorCodeEnum.PROCESS_AFTER_SALE_RETURN_GOODS);
        }
        try {
            return orderAfterSaleService.processApplyAfterSale(returnGoodsOrderRequest);
        } finally {
            redisLock.unlock(key);
        }
    }
    ...
}

@Service
public class OrderAfterSaleServiceImpl implements OrderAfterSaleService {
    ...
    //处理售后申请入口
    //当前业务限制说明：
    //目前业务限定，一笔订单包含多笔订单条目，每次手动售后只能退一笔条目，不支持单笔条目多次退不同数量
    //举例：
    //一笔订单包含订单条目A（购买数量10）和订单条目B（购买数量1），每一次可单独发起 售后订单条目A or 售后订单条目B
    //如果是售后订单条目A，那么就是把A中购买数量10全部退掉
    //如果是售后订单条目B，那么就是把B中购买数量1全部退款
    //暂不支持第一次退A中的3条，第二次退A中的2条，第三次退A中的5条这种退法
    @Override
    @Transactional(rollbackFor = Exception.class)
    public JsonResult<Boolean> processApplyAfterSale(ReturnGoodsOrderRequest returnGoodsOrderRequest) {
        //分布式锁
        String orderId = returnGoodsOrderRequest.getOrderId();
        String key = RedisLockKeyConstants.REFUND_KEY + orderId;
        boolean lock = redisLock.lock(key);
        if (!lock) {
            throw new OrderBizException(OrderErrorCodeEnum.PROCESS_AFTER_SALE_RETURN_GOODS);
        }
        try {
            //参数校验
            checkAfterSaleRequestParam(returnGoodsOrderRequest);
            //1.售后单状态验证
            //用order id和sku code查到售后id
            String skuCode = returnGoodsOrderRequest.getSkuCode();
            List<AfterSaleItemDO> orderIdAndSkuCodeList = afterSaleItemDAO.getOrderIdAndSkuCode(orderId, skuCode);
            if (!orderIdAndSkuCodeList.isEmpty()) {
                Long afterSaleId = orderIdAndSkuCodeList.get(0).getAfterSaleId();
                //用售后id查售后支付表
                AfterSaleRefundDO afterSaleRefundDO = afterSaleRefundDAO.findOrderAfterSaleStatus(String.valueOf(afterSaleId));
                //幂等校验：售后支付表里存在当前这笔未退款的记录 不能重复发起售后
                if (orderId.equals(afterSaleRefundDO.getOrderId()) && RefundStatusEnum.UN_REFUND.getCode().equals(afterSaleRefundDO.getRefundStatus())) {
                    throw new OrderBizException(OrderErrorCodeEnum.PROCESS_APPLY_AFTER_SALE_CANNOT_REPEAT);
                }
                //业务校验：已完成支付退款的订单不能再次重复发起手动售后
                AfterSaleInfoDO afterSaleInfoDO = afterSaleInfoDAO.getOneByAfterSaleId(afterSaleId);
                if (afterSaleInfoDO.getAfterSaleStatus() > AfterSaleStatusEnum.REFUNDING.getCode()) {
                    throw new OrderBizException(OrderErrorCodeEnum.PROCESS_APPLY_AFTER_SALE_CANNOT_REPEAT);
                }
            }
            //2.封装数据
            ReturnGoodsAssembleRequest returnGoodsAssembleRequest = buildReturnGoodsData(returnGoodsOrderRequest);
            //3.计算退货金额
            returnGoodsAssembleRequest = calculateReturnGoodsAmount(returnGoodsAssembleRequest);
            //4.售后数据落库
            insertReturnGoodsAfterSale(returnGoodsAssembleRequest, AfterSaleStatusEnum.COMMITED.getCode());
            //5.发起客服审核
            CustomerReviewReturnGoodsRequest customerReviewReturnGoodsRequest = returnGoodsAssembleRequest.clone(new CustomerReviewReturnGoodsRequest());
            customerApi.customerAudit(customerReviewReturnGoodsRequest);
        } catch (BaseBizException e) {
            log.error("system error", e);
            return JsonResult.buildError(e.getMessage());
        } finally {
            redisLock.unlock(key);
        }
        return JsonResult.buildSuccess(true);
    }
    ...
}

//售后退货入参
@Data
public class ReturnGoodsOrderRequest extends AbstractObject implements Serializable {
    private static final long serialVersionUID = 4893844329777688246L;
    private String orderId;//订单号
    private Integer businessIdentifier;//接入方业务线标识  1, "自营商城"
    private String userId;//用户id
    private Integer returnGoodsCode;//退货原因选项
    private String returnGoodsDesc;//退货原因说明
    private String skuCode;//退货sku编号
}
```

<br>

**(4)客服审核售后接口**

**一.使用场景**

客服审核⽤户的售后请求，分为审核通过和审核拒绝。审核通过后，⾃动发起退款。

<br>

**二.具体实现**

<img width="100%" height="100%" alt="image" src="https://github.com/user-attachments/assets/893e6b7a-a4ed-41ea-916b-fb41e57cf4fd" />

```
@Service
public class OrderAfterSaleServiceImpl implements OrderAfterSaleService {
    ...
    //接收客服审核结果入口
    @Override
    public JsonResult<Boolean> receiveCustomerAuditResult(CustomerReviewReturnGoodsRequest customerReviewReturnGoodsRequest) {
        //分布式锁
        String orderId = customerReviewReturnGoodsRequest.getOrderId();
        String key = RedisLockKeyConstants.REFUND_KEY + orderId;
        boolean lock = redisLock.lock(key);
        if (!lock) {
            throw new OrderBizException(OrderErrorCodeEnum.PROCESS_AFTER_SALE_RETURN_GOODS);
        }

        try {
            //组装售后数据
            CustomerAuditAssembleRequest customerAuditAssembleRequest = new CustomerAuditAssembleRequest();
            Long afterSaleId = customerReviewReturnGoodsRequest.getAfterSaleId();
            customerAuditAssembleRequest.setAfterSaleId(afterSaleId);
            customerAuditAssembleRequest.setAfterSaleRefundId(customerReviewReturnGoodsRequest.getAfterSaleRefundId());
            Integer auditResult = customerReviewReturnGoodsRequest.getAuditResult();
            customerAuditAssembleRequest.setReviewTime(new Date());
            customerAuditAssembleRequest.setReviewSource(CustomerAuditSourceEnum.SELF_MALL.getCode());
            customerAuditAssembleRequest.setReviewReasonCode(auditResult);
            customerAuditAssembleRequest.setAuditResultDesc(customerReviewReturnGoodsRequest.getAuditResultDesc());
            AfterSaleInfoDO afterSaleInfoDO = afterSaleInfoDAO.getOneByAfterSaleId(customerReviewReturnGoodsRequest.getAfterSaleId());

            //幂等校验：防止客服重复审核订单
            if (afterSaleInfoDO.getAfterSaleStatus() > AfterSaleStatusEnum.COMMITED.getCode()) {
                throw new OrderBizException(OrderErrorCodeEnum.CUSTOMER_AUDIT_CANNOT_REPEAT);
            }

            if (CustomerAuditResult.ACCEPT.getCode().equals(auditResult)) {
                //客服审核通过
                AfterSaleItemDO afterSaleItemDO = afterSaleItemDAO.getOrderIdAndAfterSaleId(orderId, afterSaleId);
                if (afterSaleItemDO == null) {
                    throw new OrderBizException(OrderErrorCodeEnum.AFTER_SALE_ITEM_CANNOT_NULL);
                }
                //更新售后信息
                customerAuditAssembleRequest.setReviewReason(CustomerAuditResult.ACCEPT.getMsg());
                afterSaleInfoDAO.updateCustomerAuditAfterSaleResult(AfterSaleStatusEnum.REVIEW_PASS.getCode(), customerAuditAssembleRequest);
                AfterSaleLogDO afterSaleLogDO = afterSaleOperateLogFactory.get(afterSaleInfoDO, AfterSaleStatusChangeEnum.AFTER_SALE_CUSTOMER_AUDIT_PASS);
                afterSaleLogDAO.save(afterSaleLogDO);
                //执行退款
                ActualRefundMessage actualRefundMessage = new ActualRefundMessage();
                actualRefundMessage.setAfterSaleRefundId(customerAuditAssembleRequest.getAfterSaleRefundId());
                actualRefundMessage.setOrderId(customerAuditAssembleRequest.getOrderId());
                actualRefundMessage.setLastReturnGoods(customerAuditAssembleRequest.isLastReturnGoods());
                actualRefundMessage.setAfterSaleId(customerAuditAssembleRequest.getAfterSaleId());
                //发送实际退款消息到MQ
                defaultProducer.sendMessage(RocketMqConstant.ACTUAL_REFUND_TOPIC, JSONObject.toJSONString(actualRefundMessage), "实际退款");
            } else if (CustomerAuditResult.REJECT.getCode().equals(auditResult)) {
                customerAuditAssembleRequest.setReviewReason(CustomerAuditResult.REJECT.getMsg());
                //审核拒绝更新售后信息
                afterSaleInfoDAO.updateCustomerAuditAfterSaleResult(AfterSaleStatusEnum.REVIEW_REJECTED.getCode(), customerAuditAssembleRequest);
                AfterSaleLogDO afterSaleLogDO = afterSaleOperateLogFactory.get(afterSaleInfoDO, AfterSaleStatusChangeEnum.AFTER_SALE_CUSTOMER_AUDIT_REJECT);
                afterSaleLogDAO.save(afterSaleLogDO);
            }
        } catch (BaseBizException e) {
            log.error("system error", e);
            return JsonResult.buildError(e.getMessage());
        } finally {
            redisLock.unlock(key);
        }
        return JsonResult.buildSuccess(true);
    }
    ...
}

//客服审核退货申请入参
@Data
public class CustomerReviewReturnGoodsRequest extends AbstractObject implements Serializable {
    private static final long serialVersionUID = 5541950604615013941L;
    private Long afterSaleId;//售后id
    private String customerId;//客服id
    private Integer auditResult;//审核结果 1 审核通过  2 审核拒绝
    private Long afterSaleRefundId;//售后支付单id
    private String orderId;//订单id
    private String auditResultDesc;//客服审核结果描述信息
}

//实际退款消费者
@Component
public class ActualRefundListener implements MessageListenerConcurrently {
    @Autowired
    private OrderAfterSaleService orderAfterSaleService;

    @Override
    public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> list, ConsumeConcurrentlyContext consumeConcurrentlyContext) {
        try {
            for (MessageExt messageExt : list) {
                String message = new String(messageExt.getBody());
                ActualRefundMessage actualRefundMessage = JSONObject.parseObject(message, ActualRefundMessage.class);
                log.info("ActualRefundConsumer message:{}", message);
                JsonResult<Boolean> jsonResult = orderAfterSaleService.refundMoney(actualRefundMessage);
                if (!jsonResult.getSuccess()) {
                    throw new OrderBizException(jsonResult.getErrorCode(), jsonResult.getErrorMessage());
                }
            }
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
        } catch (Exception e) {
            log.error("consumer error", e);
            return ConsumeConcurrentlyStatus.RECONSUME_LATER;
        }
    }
}

@Service
public class OrderAfterSaleServiceImpl implements OrderAfterSaleService {
    ...
    //执行退款
    @Override
    public JsonResult<Boolean> refundMoney(ActualRefundMessage actualRefundMessage) {
        Long afterSaleId = actualRefundMessage.getAfterSaleId();
        String key = RedisLockKeyConstants.REFUND_KEY + afterSaleId;
        try {
            boolean lock = redisLock.lock(key);
            if (!lock) {
                throw new OrderBizException(OrderErrorCodeEnum.REFUND_MONEY_REPEAT);
            }
            AfterSaleInfoDO afterSaleInfoDO = afterSaleInfoDAO.getOneByAfterSaleId(actualRefundMessage.getAfterSaleId());
            Long afterSaleRefundId = actualRefundMessage.getAfterSaleRefundId();
            AfterSaleRefundDO afterSaleRefundDO = afterSaleRefundDAO.getById(afterSaleRefundId);
            //1.封装调用支付退款接口的数据
            PayRefundRequest payRefundRequest = buildPayRefundRequest(actualRefundMessage, afterSaleRefundDO);
            //2.执行退款
            if (!payApi.executeRefund(payRefundRequest)) {
                throw new OrderBizException(OrderErrorCodeEnum.ORDER_REFUND_AMOUNT_FAILED);
            }
            //3.售后记录状态
            //执行退款更新售后信息
            updateAfterSaleStatus(afterSaleInfoDO, AfterSaleStatusEnum.REVIEW_PASS.getCode(), AfterSaleStatusEnum.REFUNDING.getCode());
            //4.退货的最后一笔退优惠券
            if (actualRefundMessage.isLastReturnGoods()) {
                //释放优惠券权益
                String orderId = actualRefundMessage.getOrderId();
                OrderInfoDO orderInfoDO = orderInfoDAO.getByOrderId(orderId);
                CancelOrderReleaseUserCouponRequest cancelOrderReleaseUserCouponRequest = orderInfoDO.clone(CancelOrderReleaseUserCouponRequest.class);
                defaultProducer.sendMessage(RocketMqConstant.CANCEL_RELEASE_PROPERTY_TOPIC, JSONObject.toJSONString(cancelOrderReleaseUserCouponRequest), "释放优惠券权益");
            }
            return JsonResult.buildSuccess(true);
        } catch (OrderBizException e) {
            log.error("system error", e);
            return JsonResult.buildError(e.getMessage());
        } finally {
            redisLock.unlock(key);
        }
    }
    ...
}
```

<br>

**(5)缺品接口**

**一.使用场景**

当订单履约后，会被推送到履约系统。捡货⼈员根据订单要求拣货时，发现有商品缺货，就会直接对订单进⾏缺品退款，然后缺品部分的钱直接回退到⽤户账户去。

<br>

**二.业务规则**

缺品的商品sku的数量不能超过下订单商品sku数量，只有⽀付之后，配送之前才可以发起缺品。

<br>

**三.具体实现**

订单系统收到缺品请求后：⾸先对缺品请求进⾏业务规则校验，校验失败直接抛异常，校验成功进⼊缺品退款处理流程。然后，具体的处理流程是构造缺品类型售后单、售后单条⽬、售后退款单，并插⼊数据库，将缺品信息(缺品数量、sku、⾦额)存储在订单的扩展字段⾥(ext_json)。

```
计算订单缺品退款总⾦额 = 每个缺品sku的缺品退款⾦额总和；
计算单个缺品sku的退款⾦额 = (缺品数量 / 下单数量) * 原付款⾦额；
```

接着，发送退款消息ActualRefundMessage到RocketMQ。当订单系统的退款消息消费者收到退款消息后就会发起退款流程，即退款消息消费者ActualRefundConsumer会将钱退还给⽤户。

<img width="100%" height="100%" alt="image" src="https://github.com/user-attachments/assets/8799ee43-c352-4299-8ede-aedd51c6a300" />

<br>

**四.技术要点**

**要点一：** 本地事务和发送MQ消息消息的最终⼀致性

**要点二：** 接⼝幂等，同样的缺品请求发送多次不会⽣成多条缺品记录，通过分布式锁 + 前置校验实现

```
@RestController
@RequestMapping("/afterSale")
public class AfterSaleController {
    ...
    //缺品请求
    @PostMapping("/lackItem")
    public JsonResult<LackDTO> lackItem(@RequestBody LackRequest request) {
        JsonResult<LackDTO> result = afterSaleApi.lackItem(request);
        return result;
    }
    ...
}

//订单中心-逆向售后业务接口
@DubboService(version = "1.0.0", interfaceClass = AfterSaleApi.class, retries = 0)
public class AfterSaleApiImpl implements AfterSaleApi {
    @Autowired
    private OrderLackService orderLackItemService;
    ...

    //缺品接口
    @Override
    public JsonResult<LackDTO> lackItem(LackRequest request) {
        try {
            //1.参数校验
            CheckLackDTO checkResult = orderLackItemService.checkRequest(request);
            //2.缺品处理
            return JsonResult.buildSuccess(orderLackItemService.executeLackRequest(request, checkResult));
        } catch (OrderBizException e) {
            log.error("biz error", e);
            return JsonResult.buildError(e.getErrorCode(), e.getErrorMsg());
        } catch (Exception e) {
            log.error("error", e);
            return JsonResult.buildError(e.getMessage());
        }
    }
    ...
}

//订单缺品请求
@Data
public class LackRequest extends AbstractObject implements Serializable {
    private String orderId;//订单号
    private String userId;//用户id
    private Set<LackItemRequest> lackItems;//具体的缺品项
}

//具体的缺品项
@Data
public class LackItemRequest extends AbstractObject implements Serializable {
    private String skuCode;//sku编码
    private Integer lackNum;//缺品数量
}

@Service
public class OrderLackServiceImpl implements OrderLackService {
    ...
    //校验入参
    @Override
    public CheckLackDTO checkRequest(LackRequest request) throws OrderBizException {
        //1.参数基本校验
        ParamCheckUtil.checkStringNonEmpty(request.getOrderId(), OrderErrorCodeEnum.ORDER_ID_IS_NULL);
        ParamCheckUtil.checkCollectionNonEmpty(request.getLackItems(), OrderErrorCodeEnum.LACK_ITEM_IS_NULL);
        //2.查询订单
        OrderInfoDO order = orderInfoDAO.getByOrderId(request.getOrderId());
        ParamCheckUtil.checkObjectNonNull(order, OrderErrorCodeEnum.ORDER_NOT_FOUND);
        //3.校验订单是否可以发起缺品
        if (!OrderStatusEnum.canLack().contains(order.getOrderStatus())) {
            throw new OrderBizException(OrderErrorCodeEnum.ORDER_NOT_ALLOW_TO_LACK);
        }
        //4.查询订单item
        List<OrderItemDO> orderItems = orderItemDAO.listByOrderId(request.getOrderId());
        //5.校验具体的缺品项
        List<LackItemDTO> lackItems = new ArrayList<>();
        for (LackItemRequest itemRequest : request.getLackItems()) {
            lackItems.add(checkLackItem(order, orderItems, itemRequest));
        }
        //6.构造返参
        return new CheckLackDTO(order, lackItems);
    }

    //缺品处理
    @Transactional(rollbackFor = Exception.class)
    @Override
    public LackDTO executeLackRequest(LackRequest request, CheckLackDTO checkLackItemDTO) {
        OrderInfoDO order = checkLackItemDTO.getOrder();
        List<LackItemDTO> lackItems = checkLackItemDTO.getLackItems();
        //1.生成缺品售后单
        AfterSaleInfoDO lackAfterSaleOrder = buildLackAfterSaleInfo(order);
        //2.生成缺品售后单item
        List<AfterSaleItemDO> afterSaleItems = new ArrayList<>();
        lackItems.forEach(item -> {
            afterSaleItems.add(buildLackAfterSaleItem(order, lackAfterSaleOrder, item));
        });
        //3.计算订单缺品退款总金额
        Integer lackApplyRefundAmount = afterSaleAmountService.calculateOrderLackApplyRefundAmount(afterSaleItems);
        Integer lackRealRefundAmount = afterSaleAmountService.calculateOrderLackRealRefundAmount(afterSaleItems);
        lackAfterSaleOrder.setApplyRefundAmount(lackApplyRefundAmount);
        lackAfterSaleOrder.setRealRefundAmount(lackRealRefundAmount);
        //4.构造售后退款单
        AfterSaleRefundDO afterSaleRefund = buildLackAfterSaleRefundDO(order, lackAfterSaleOrder);
        //5.构造订单缺品扩展信息
        OrderExtJsonDTO lackExtJson = buildOrderLackExtJson(request, order, lackAfterSaleOrder);
        //6.存储售后单、item和退款单
        afterSaleInfoDAO.save(lackAfterSaleOrder);
        afterSaleItemDAO.saveBatch(afterSaleItems);
        afterSaleRefundDAO.save(afterSaleRefund);
        //更新订单扩展信息
        orderInfoDAO.updateOrderExtJson(order.getOrderId(), lackExtJson);
        //7.发送缺品退款的消息
        sendLackRefund(order, lackAfterSaleOrder, afterSaleRefund.getId());
        // TODO 使用RocketMQ 事务消息保证本地事务 + 发送缺品退款消息的最终一致性
        return new LackDTO(order.getOrderId(), lackAfterSaleOrder.getAfterSaleId());
    }
    ...
}
```

<br>

**(6)用户撤销售后申请**

**一.业务规则**

只有提交申请状态才可以撤销。

<br>

**二.具体实现**

步骤一：接收撤销售后申请请求

步骤二：查询售后单

步骤三：进⾏业务规则判断

步骤四：加refund_key的分布式锁

步骤五：更新售后单状态为已撤销

步骤六：增加⼀条售后单操作⽇志

步骤七：释放锁

<img width="100%" height="100%" alt="image" src="https://github.com/user-attachments/assets/22545706-7634-4318-9d4e-9580e926a2bb" />

<br>

**三.技术要点**

加refund_key的分布式锁：只要涉及售后表的更新，就需要加锁，锁整个售后表。否则算钱的时候，就会由于突然撤销，导致钱多算了。

```
//订单中心-逆向售后业务接口
@DubboService(version = "1.0.0", interfaceClass = AfterSaleApi.class, retries = 0)
public class AfterSaleApiImpl implements AfterSaleApi {
    @Autowired
    private OrderAfterSaleService orderAfterSaleService;
    ...

    @Override
    public JsonResult<Boolean> revokeAfterSale(RevokeAfterSaleRequest request) {
        //1.参数校验
        ParamCheckUtil.checkObjectNonNull(request.getAfterSaleId(), OrderErrorCodeEnum.AFTER_SALE_ID_IS_NULL);
        //2.撤销申请
        orderAfterSaleService.revokeAfterSale(request);
        return JsonResult.buildSuccess(true);
    }
    ...
}

@Service
public class OrderAfterSaleServiceImpl implements OrderAfterSaleService {
    ...
    //撤销售后申请
    @Override
    public void revokeAfterSale(RevokeAfterSaleRequest request) {
        //1.查询售后单
        Long afterSaleId = request.getAfterSaleId();
        AfterSaleInfoDO afterSaleInfo = afterSaleInfoDAO.getOneByAfterSaleId(afterSaleId);
        ParamCheckUtil.checkObjectNonNull(afterSaleInfo, OrderErrorCodeEnum.AFTER_SALE_ID_IS_NULL);
        //2.校验售后单是否可以撤销：只有提交申请状态才可以撤销
        if (!AfterSaleStatusEnum.COMMITED.getCode().equals(afterSaleInfo.getAfterSaleStatus())) {
            throw new OrderBizException(OrderErrorCodeEnum.AFTER_SALE_CANNOT_REVOKE);
        }
        //3.加锁,锁整个售后单
        //只要涉及售后表的更新，就需要加锁，锁整个售后表，否则算钱的时候，就会由于突然撤销，导致钱多算了
        String lockKey = RedisLockKeyConstants.REFUND_KEY + afterSaleId;
        try {
            boolean isLock = redisLock.lock(lockKey);
            if (!isLock) {
                throw new OrderBizException(OrderErrorCodeEnum.AFTER_SALE_CANNOT_REVOKE);
            }
            //4.更新售后单状态为："已撤销"
            afterSaleInfoDAO.updateStatus(afterSaleId, AfterSaleStatusEnum.COMMITED.getCode(), AfterSaleStatusEnum.REVOKE.getCode());
            //5.增加一条售后单操作日志
            afterSaleLogDAO.save(afterSaleOperateLogFactory.get(afterSaleInfo, AfterSaleStatusChangeEnum.AFTER_SALE_REVOKE));
        } finally {
            //6.释放锁
            redisLock.unlock(lockKey);
        }
    }
    ...
}
```

<br>

**(7)自动取消超时订单任务接口**

**一.使用场景**

后台定时任务每间隔⼀定时间就会扫描系统中超过30min未⽀付的订单，然后对其进⾏取消。

<br>

**二.具体实现**

**步骤一：** Spring Schedule启动⼀个调度任务，每隔30分运行一次扫描系统中所有状态是未⽀付的订单

**步骤二：** 对每⼀条订单进⾏超时判断，只要currentTime - expireTime >= 30min，就认为订单已超时，需要取消

**步骤三：** 对需要取消的订单调⽤订单取消接口

<br>

**三.技术要点**

**要点一：** 如何保证不会扫描太多订单，只扫描⼀定时间内的未⽀付订单

**要点二：** 换成xxxjob来实现

```
//自动取消超时订单任务
@Component
public class AutoCancelExpiredOrderTask {
    public static final Integer ORDER_EXPIRE_TIME = 30 * 60 * 1000;
    ...

    //执行任务逻辑
    @Scheduled(fixedRate = 30 * 60 * 1000)
    public void execute() {
        //扫描当前时间 - 订单超时时间 -> 前的一小段时间范围(时间范围用配置中心配置)
        //比如当前时间11:40，订单超时时间是30分钟，扫描11:09:00 -> 11:10:00这一分钟的未支付订单，
        //缺点：有一个订单超过了30 + 1 = 31分钟，都没有被处理(取消)，这笔订单就永久待支付
        for (OrderInfoDO order : orderInfoDAO.listAllUnPaid()) {
            if (new Date().getTime() - order.getExpireTime().getTime() >= orderProperties.getExpireTime()) {
                //超过30min未支付
                CancelOrderRequest request = new CancelOrderRequest();
                request.setOrderId(order.getOrderId());
                request.setUserId(order.getUserId());
                request.setBusinessIdentifier(order.getBusinessIdentifier());
                request.setOrderType(order.getOrderType());
                request.setCancelType(OrderCancelTypeEnum.TIMEOUT_CANCELED.getCode());
                request.setOrderStatus(order.getOrderStatus());
                try {
                    orderAfterSaleService.cancelOrder(request);
                } catch (Exception e) {
                    log.error("AutoCancelExpiredOrderTask execute error:", e);
                }
            }
        }
    }
}
```

<br>

**(8)查询售后列表接口**

**一.业务规则**

售后列表和详情只能看到⽤户主动发起的售后退款记录，超时⾃动取消和⽤户⼿动取消的售后单不展示，通过售后单的类型售后类型来区分。

<br>

**二.字段映射梳理**

```
1.⼊参和表字段映射关系梳理
业务线：businessIdentifier -> after_sale_info.business_identifier
订单类型：orderTypes -> after_sale_info.order_type
售后单号：afterSaleIds -> after_sale_info.order_id
订单号：orderIds -> after_sale_info.order_id
⽤户ID：userIds -> after_sale_info.user_id
售后单状态：afterSaleStatus -> after_sale_info.after_sale_status
售后申请来源：applySources -> after_sale_info.apply_source
售后类型：afterSaleTypes -> after_sale_info.after_sale_type
售后申请时间-开始/截⽌：startApplyTime，endApplyTime -> after_sale_info.apply_time
售后客户审核时间-开始/截⽌：startReviewTime，endReviewTime-> after_sale_info.review_time
退款⽀付时间-开始/截⽌：startRefundPayTime，endRefundPayTime-> after_sale_pay.refund_pay_time
创建时间-开始/截⽌：startCreatedTime，endCreatedTime -> after_sale_pay.gmt_create
退款⾦额-区间开始/区间截⽌：startRefundAmount,endRefundAmount -> after_sale_pay.refund_amount 
skuCodes -> after_sale_detail.sku_id

2.返回结果和数据表字段映射关系梳理
业务线：businessIdentifier -> after_sale_info.business_identifier
售后单ID：afterSaleId -> after_sale_info.after_sale_id
订单ID：orderId -> after_sale_info.order_id
订单类型：orderType -> after_sale_info.order_type
买家ID：userId-> after_sale_info.user_id
售后单状态：orderStatus -> after_sale_info.after_sale_status
申请售后来源：applySource -> after_sale_info.apply_source
申请时间：applyTime -> after_sale_info.apply_time
申请原因编码：applyReasonCode -> after_sale_info.apply_reason_code
申请原因描述：applyReason -> after_sale_info.apply_reason
客服审核时间：reviewTime -> after_sale_info.reviewTime
客服审核结果编码：reviewReasonCode -> after_sale_info.review_reason_code
客服审核结果：reviewReason -> after_sale_info.review_reason
备注：remark -> after_sale_info.remark
售后类型：afterSaleType -> after_sale_info.after_sale_type
售后类型详情：afterSaleTypeDetail -> after_sale_info.after_sale_type_detail
sku code：skuCode -> after_sale_item.sku_code
商品名称：productName -> after_sale_item.product_name
商品图⽚：productImg -> after_sale_item.product_img
商品退货数量：returnQuantity -> after_sale_item.return_quantity
商品总⾦额：originAmount -> after_sale_item.origin_amount
申请退款⾦额：applyRefundAmount -> after_sale_item.apply_refund_amount
实际退款⾦额：realRefundAmount -> after_sale_item.real_refund_amount
```

<br>

**三.具体实现**

步骤一：组装业务查询规则

步骤二：连表分⻚查询after_sale_info、after_sale_detail、after_sale_pay，具体的字段映射如上⽅的⼊参和表字段映射关系梳理

步骤三：如果没有排序字段，默认按创建时间降序

步骤四：查询出来的每条记录根据映射关系梳理，查询对应数据表。然后组装返参，返回给调⽤⽅

步骤五：通过Builder模式构建复杂查询业务规则

```
//订单中心-售后查询业务接口
@DubboService(version = "1.0.0", interfaceClass = AfterSaleQueryApi.class)
public class AfterSaleQueryApiImpl implements AfterSaleQueryApi {
    @Autowired
    private AfterSaleQueryService afterSaleQueryService;

    //查询售后列表
    @Override
    public JsonResult<PagingInfo<AfterSaleOrderListDTO>> listAfterSales(AfterSaleQuery query) {
        try {
            //1.参数校验
            afterSaleQueryService.checkQueryParam(query);
            //2.查询
            return JsonResult.buildSuccess(afterSaleQueryService.executeListQuery(query));
        } catch (OrderBizException e) {
            log.error("biz error", e);
            return JsonResult.buildError(e.getErrorCode(), e.getErrorMsg());
        } catch (Exception e) {
            log.error("error", e);
            return JsonResult.buildError(e.getMessage());
        }
    }
    ...
}

@Service
public class AfterSaleQueryServiceImpl implements AfterSaleQueryService {
    ...
    @Override
    public PagingInfo<AfterSaleOrderListDTO> executeListQuery(AfterSaleQuery query) {
        //当前采用连表查询
        //后续会接入ES
        //1.组装业务查询规则
        AfterSaleListQueryDTO queryDTO = AfterSaleListQueryDTO.Builder.builder()
            .copy(query)
            //默认只展示用户主动发起的售后单
            .userApplySource()
            .setPage(query)
            .build();
        //2.查询
        Page<AfterSaleOrderListDTO> page = afterSaleInfoDAO.listByPage(queryDTO);
        //3.转化
        return PagingInfo.toResponse(page.getRecords(), page.getTotal(), (int) page.getCurrent(), (int) page.getSize());
    }
    ...
}

//查询售后列表的入参
@Data
public class AfterSaleQuery extends AbstractObject implements Serializable {
    public static final Integer MAX_PAGE_SIZE = 100;
    private Integer businessIdentifier;//业务线
    private Set<Integer> orderTypes;//订单类型
    private Set<Integer> afterSaleStatus;//售后单状态
    private Set<Integer> applySources;//售后申请来源
    private Set<Integer> afterSaleTypes;//售后类型
    private Set<Long> afterSaleIds;//售后单号
    private Set<String> orderIds;//订单号
    private Set<String> userIds;//用户ID
    private Set<String> skuCodes;//sku code
    private Pair<Date, Date> createdTimeInterval;//创建时间-查询区间
    private Pair<Date, Date> applyTimeInterval;//售后申请时间-查询区间
    private Pair<Date, Date> reviewTimeInterval;//售后客服审核时间-查询区间
    private Pair<Date, Date> refundPayTimeInterval;//退款支付时间-查询区间
    private Pair<Integer, Integer> refundAmountInterval;退款金额-查询区间
    private Integer pageNo = 1;//页码；默认为1；private Integer pageSize = 20;//一页的数据量. 默认为20
}

//售后单列表DTO
@Data
public class AfterSaleOrderListDTO extends AbstractObject implements Serializable {
    private Integer businessIdentifier;//接入方业务标识
    private String afterSaleId;//售后单号
    private String orderId;//订单号
    private Integer orderType;//订单类型
    private String userId;//买家编号
    private Integer orderAmount;//订单实付金额
    private Integer afterSaleStatus;//售后单状态
    private Integer applySource;//申请售后来源
    private Date applyTime;//申请售后时间
    private Integer applyReasonCode;//申请理由编码
    private String applyReason;//申请理由描述
    private Date reviewTime;//客服审核时间
    private Long reviewReasonCode;//客服审核结果编码
    private String reviewReason;//客服审核结果
    private String remark;//备注
    private Integer afterSaleType;//售后类型
    private Integer afterSaleTypeDetail;//售后类型详情
    private String skuCode;//sku code
    private String productName;//商品名
    private String productImg;//商品图片地址
    private Integer returnQuantity;//商品退货数量
    private Integer originAmount;//商品总金额
    private Integer applyRefundAmount;//申请退款金额
    private Integer realRefundAmount;//实际退款金额
}
```

<br>

**(9)查询售后详情接口**

```
//订单中心-售后查询业务接口
@DubboService(version = "1.0.0", interfaceClass = AfterSaleQueryApi.class)
public class AfterSaleQueryApiImpl implements AfterSaleQueryApi {
    @Autowired
    private AfterSaleQueryService afterSaleQueryService;
    ...

    //查询售后单详情
    @Override
    public JsonResult<AfterSaleOrderDetailDTO> afterSaleDetail(Long afterSaleId) {
        try {
            //1.参数校验
            ParamCheckUtil.checkObjectNonNull(afterSaleId, OrderErrorCodeEnum.AFTER_SALE_ID_IS_NULL);
            //2.查询
            return JsonResult.buildSuccess(afterSaleQueryService.afterSaleDetail(afterSaleId));
        } catch (OrderBizException e) {
            log.error("biz error", e);
            return JsonResult.buildError(e.getErrorCode(), e.getErrorMsg());
        } catch (Exception e) {
            log.error("error", e);
            return JsonResult.buildError(e.getMessage());
        }
    }
}

@Service
public class AfterSaleQueryServiceImpl implements AfterSaleQueryService {
    ...
    @Override
    public AfterSaleOrderDetailDTO afterSaleDetail(Long afterSaleId) {
        //1.查询售后单
        AfterSaleInfoDO afterSaleInfo = afterSaleInfoDAO.getOneByAfterSaleId(afterSaleId);
        if (null == afterSaleInfo) {
            return null;
        }
        //2.查询售后单条目
        List<AfterSaleItemDO> afterSaleItems = afterSaleItemDAO.listByAfterSaleId(afterSaleId);
        //3.查询售后支付信息
        List<AfterSaleRefundDO> afterSalePays = afterSaleRefundDAO.listByAfterSaleId(afterSaleId);
        //4.查询售后日志
        List<AfterSaleLogDO> afterSaleLogs = afterSaleLogDAO.listByAfterSaleId(afterSaleId);
        //5.构造返参
        return new AfterSaleOrderDetailBuilder()
            .afterSaleInfo(afterSaleInfo)
            .afterSaleItems(afterSaleItems)
            .afterSalePays(afterSalePays)
            .build();
    }
    ...
}

//售后单详情DTO
@Data
public class AfterSaleOrderDetailDTO implements Serializable {
    private AfterSaleInfoDTO afterSaleInfo;//售后信息
    private List<AfterSaleItemDTO> afterSaleItems;//售后单条目
    private List<AfterSalePayDTO> afterSalePays;//售后支付信息
    private List<AfterSaleLogDTO> afterSaleLogs;//售后单日志
}
```
